>> Hello. In this lecture, we are going to look at ballistic projectiles. So we are going to consider this scenario where an agent needs to throw or launch a projectile at a target. And this target could be stationary or moving. We might also need to consider other situations like this gravity effect the projectile. Do we have drag? What other conditions could affect either the projectile or the target? So our agents sometimes need to be able to fire these projectiles, and we need to figure out a way to get the agent to aim such that the projectile ends up at the right place. Now these are ballistic projectiles. That means that in terms of the simulation, the projectile is picking up all of its velocity in one single time step. So in real life, the ballistic projectile is accelerated over a very short period of time. And then there's no further acceleration, at least in terms of setting the trajectory, the initial velocity. If now the projectile could change velocity over time, but usually that is because of gravity. Or perhaps drag would be affecting the projectile as well. So it's easy to simulate Newtonian physics with particle dynamics or rigid body dynamics. These are things you're probably already familiar with from high school physics. Calculating based on different equations, or maybe even working with calculus to actually derive these equations. It's generally easy to simulate Newtonian physics, but solving for intercepts is not always easy. So we've tackled this problem to some degree before you may recall from the steering behavior lecture, we introduced pursue. Pursue is a predictive seek trying to find the right path to get our agent to a moving target. And the way that algorithm was approached was to use an approximate heuristic. And that was really motivated by minimizing the computational cost because this is something that we're calculating over and over every single frame. So this could easily take up a lot of our computational resources, especially if we have many agents in there all needing to do the same pursue calculation. So the way that this worked was we would determine a time that the intercept would occur. So we solve for t, but did so in an approximate way. And the way it worked is we figured out, well what's the distance from the agent to the target that's moving? And based on that distance for that relative vector, the magnitude, we can divide it by the speed at which the agent is going to move. So we would assume just like going full speed ahead, what's the maximum speed the agent can go? We'll assume that is the case for the whole trip. So this doesn't take into account that the target heading away from us or towards us, or to the agent. And we're just coming up with an approximate approach. So the length of that relative position vector, like magnitude divided by the velocity will give us t. Now that we have that t value, we extrapolated the target's movement. So the target has a current position. We can add to that current position velocity of the target times this estimated t. That'll tell us a future position of the target. The agent, that's chasing or pursuing can then just seek to that future position. So we're only using an estimate again because we don't need it to be precise, we are focused more on being efficient and just generally getting us closer, and converging on the correct solution. But in the case of a ballistic projectile, we only get to set the velocity one time and then we have no longer any programmatic control over that velocity. We have to just let it continue course. Perhaps if there's gravity, gravity will be acting on it, but there's no intelligent adjustment like I say, a homing missile which would use basically pursue or something similar to pursue in the calculation. So we need to spend more time making sure our calculation is correct because we only have this one chance if we have any hope of it being correct. So you might think of projectiles like grenades or footballs that the agent will be launching at target. And of course, those scenarios are ones where we would want this precise velocity determination for this ballistic trajectory. But there's also other scenarios you might consider as well. One might be for a character that moves on the ground. So for instance, in the Spider-Man universe, there's a bad guy Rhino. When he gets angry trying to attack Spider-Man, he charges forward. So if you're making a Spider-Man video game, you might want to implement Rhino so that he fights for awhile then it gets angry, and then charges towards Spider-Man. But Spider-Man tends to be moving around a lot. So it's not going to be very helpful, or very challenging game play if Rhino just heads to the current position of Spider-Man and stays on that course for the run. So for game play purposes, we might have Rhino use a ballistic trajectory intercept along the ground to try to head off or Spider-Man is currently running as a player say, controlling Spider-Man and moving. But then we'll take away Rhino's ability to correct course or maybe limited significantly so you can only change a tiny bit. And so that would make it challenging for game play. So the player would see that Rhino is charging towards them and then would know that they need to change direction, and make some evasive maneuver, but you don't want Rhino to have the ability to constantly update to the new velocity, new heading, because it would be impossible to get out of the way perhaps. So all of these rely on some fine tuning of speeds and various parameters of the movement. But you could very well need a ballistic trajectory of a precise calculation for that game play. >> So sometimes it's straightforward to solve an intercept. For instance, if you have a target that is not moving at all, it's just a fixed target, and your projectile has constant velocity, there's no drag, there's no gravity, you can just set it in motion and it goes forward. This might be like an outer space, perhaps launching a projectile with no gravity and the target is not moving. So if you have that situation, it's really easy to calculate. It's similar to the pursue algorithm. You just need a relative position vector that will allow you to get the launch direction, because you can normalize it to a unit vector, and then you can multiply it by your desired projectile speed and that will give you the full velocity of the projectile. So you can just set that velocity on the projectile and let it go. So here, I've got a little shooting gallery app. This is a pre-recorded video. This is a demonstration of the algorithm I just described. So it's just three lines of code or so. To fire this projectile, the gravity is turned off. So normally unity defaults to having gravity on, but in this case it is turned off. You can see what it looks like, some curvature to the path, but the way the shooting gallery works is that there's a randomly moving shooting position as the yellow cylinder sliding up and down, just randomly moves. And it's actually similar to the wander algorithm, but just limited to one dimension. And then it's calculating as if the target is fixed. Of course you can see the target, the red sphere is in fact moving, but it's moving so slowly that the projectiles are still able to hit in most cases. And you can tell that it's off a bit because the green projectiles are hitting on the backside of the target relative to the direction the target is going. But you can tell it is accurate, just in a simple algorithm and it works well if you have this scenario, there's just not a lot of degrees of freedom in terms of the solution we're trying to determine. But what would happen if gravity did affect the projectile or the target is moving or moving fast enough? So the more degrees of freedom that we had allowed the more complicated the system of equations that we would need for solving what we'll get. Eventually, the equations can get so complicated that you can't even directly solve them anymore. Or if you can, it becomes overly complicated or is prone to errors like maybe you have to break your solutions up in lots of nested conditional logic and easy to mess things up. So we can see how our simple solution fails pretty badly when we add some effects of gravity. So that right now the projectile is still moving pretty slow, but gravity, it was hitting it a little bit right there in the middle of the video but clearly it's not aiming high enough. It could potentially hit the target, but the fact that it's not taking into account the effect of gravity means that this is not a very effective algorithm for that purpose. So we will be looking at some methods for solving more complicated projectile scenarios. And there's two general methods that we can use for solving these ballistic projectile launched velocities. The first is to directly solve, and we've seen an example so far of directly solving for a trivially simple example. But we're going to see much more complicated examples or a couple, at least in the rest of this lecture series. So we'll be setting up a system of equations and then solving, finding a precise intercept time and then applying that to our motion equation for our target. And then that since we were solving for the time of the collision, plugging that into the target movement, we know that the target, after having moved by whatever amount it does in t units of time, that's going to be the same position that our projectile is going to arrive at. And so that allows us to work backwards from that point using the equation for motion of the projectile to ultimately figure out what's the initial velocity. Again, that cannot always be done. So we'll also look for how to deal with more complicated scenarios and that would be a situation where we're going to want to use an approximate approach, which we will refer to as iteratively solving. So this at a high level works by estimating a reasonable solution, and then we'll figure out how far off it is and we're going to refine the parameters of the equations until the solution is close enough to the desired outcome, should a valid outcome be possible at all. But in order to use an iterative solution, we must be able to model the projectile and target movement according to defined parameters. In some cases, we can directly solve the position of projectile and target with say, if we knew a T value, a time of intercept, we could plug it in. It's not always easy to solve that T, but in some cases, it's not even easy to solve where a projectile is at any given point in time. There's actually another level of simulation where the current position is dependent on the previous position and so we have to iteratively solve the position of the particle on top of iteratively solving our adjustments of parameters. So that makes things doubly hard and we'll revisit that issue. But next up we will discuss firing at a projectile at a static 3D target position, but the projectile will be affected by gravity. So we're going to address the issue that we just saw in the last video where the projectile was failing because of gravity.
