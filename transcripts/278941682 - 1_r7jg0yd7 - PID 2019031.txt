>> Hello. In this lecture, we are going to explore behavior trees. So behavior trees are a form of reactive decision-making. They are fairly similar to finite state machines. But you have to flip around the way you think. And the way that they're structured is different enough that the way in which you design them, I would say if it feels very different, the approach that you take n building one. But what you gain in the learning curve of a behavior tree is a big increase in flexibility. So we might think in terms of re-usability of behavior tree or specialty parts of a behavior tree, and so there's potentially big gains as compared to finite state machines. So behavior trees have become very popular to use in games, especially in the last few years, if began to, I would say replace finite state machines in terms of popularity. So we'll start off by looking at the structure of a behavior tree. So again, it does have aspects that are similar to state machines in that you often have a visualization that looks very similar, you have what look like states in the flow-chart so that you have these blocks. And some of them, like the leaves, appear to be what you might find in a state machine representing a particular behavior. So the leaves in the tree are the behaviors, and that's also similar to decision trees as well. So a behavior tree ends up being much more declarative because of the way that the behaviors are linked together. So no longer do we have these contexts, specific transitions in a finite state machine, now we have these very structured nodes that perform logical expressions of behavior. And they have this Boolean unlike characteristic, and so all the transitions end up being decoupled from the behaviors, whereas finite state machine there are unified together. And that has an impact on the re-usability, so we'll revisit that. So we have this more declarative structure. The fact that we are forming a tree means that it's more understandable or readable data structure as compared to a finite state machine, especially because we can have loops and all arbitrary connections. And however, the finite state machine gets designed, it doesn't necessarily lend itself well to reading off of a screen or a piece of paper, but with a behavior tree, we're imposing the structure, which means that it'll be really easy to read top down and left to right. So the key components are, we have composite nodes, decorator nodes and leaf nodes, and then each of these nodes can be in a state of success, failure, or running, and then also, I guess, uninitialized, if a node has not been visited, which we'll see in a bit. So again, behavior trees is a simple reactive planning, there's really nothing different that we can do with a behavior tree as compared to any other reactive planning paradigm. But it's just the way in which we organize information can make things more flexible, especially in terms of reuse. So the behavior tree that you design for an agent that specifies everything the agent can do, every contingency plan, any way in which the agent can respond is in the tree. So if unforeseen circumstances arise, if the agent doesn't have the plan built into the tree, it cannot react. And that's true for all the reactive decision-making strategies. So again, the transitions are externalized from states, and that is in the form of the composite or in decorator nodes that were able to realize this externalization of the transitions. So because we've decoupled the two, that is what enables the reuse because we've got behaviors that are realized or created, implemented in your code, that since they're not tied directly to transitions, makes it very easy to use them. If you think about a finite state machine, anytime you find a state you want to reuse, you'd have to go in and edit strip out the transitions that you don't want and then would need to re-implement those. And so that's something that's easily avoided with behavior trees. So a lot of the magic of the transitions comes from the composite or nodes, and so these operate a bit like Boolean operations for the most part. So we have AND, and OR operations. For, AND it's called a sequence composite node, and an OR is a selector composite node, and then there's random variations of these. So you can have a random sequence or a random selector that's useful, but when later on we might consider making a non-deterministic agent from a behavior tree, we can just introduce a shuffling of whatever the conditions are in the answer ORs. Now, these are not, say two Boolean comparisons, these can be evaluated in a list form that is typical for a behavior tree. So if you have the sequence, it's A and B and C and D and so on. As many conditions as you add, so you don't have to add more than one sequence node, it just has some arbitrary number of children. So this is a node in the intermediate position in the tree, and it can have an arbitrary number of children, so it's not a binary tree. The way that we might have for a, say, a decision tree is an n-ary tree. Same with selectors. Now, the real power of the behavior tree relies on short-circuiting Boolean logic. So that means if we are evaluating a sequence, so A and B and C, if a fails, returns false there's no sense in evaluating B, C, and D as well, we can just immediately say that, that sequence itself failed because one of its children failed. So it avoids evaluating further down and as we'll see, that means avoids executing behaviors that are pointless to execute. In selecting work similarly, it's an OR. As soon as one node evaluates to true, there's no point in further evaluating. And so you can imagine if you are coming up with a recipe for an agent for behaviors, there are some cases when you have sequences of things to accomplish, like you first have to put the ingredients in the blender before you turn the blender on or the key in the door and unlock it before you open the door. And so there are sequences, and of course these can be hierarchical as well. And the case of the selector, this is good for when maybe an agent is aware of a number of different candidate strategies that might work. You might order them in terms of some priority, like don't do the high energy attempt before you try the low energy attempts. So for instance, if you're trying to get into a house, you would try the door first before you climb to the roof and go in the chimney. So you can introduce priority just in terms of the ordering, and you know that you're at short-circuit the first. The first of the behaviors that is effective will return true, and there's no point in trying further any other alternative strategies. So each of these nodes returns success or failure, and that'll be based on the return value of the children. So you have a lot of returned values that get bubbled up the tree whenever the tree is evaluated, which happens every update cycle for whatever your AI update cycle is. And so generally with a composite OR node, the values that are being bubbled up, they originated from a behavior or leaf node in the tree. Now we also have decorators, and these end up being very powerful, as you will find if you try to design your own behavior tree or implement your own behavior tree. So a decorator, unlike the composite nodes, will always have one child, and this works by changing or filtering the return value of the child. So this can be used for control logic. >> May be repeating attempts of a behavior such that maybe a child would fail several times before it finally works. So such as say shooting at an enemy. You might want to continue a behavior of shooting at the enemy. And it might fail, but you don't want that single shot to cause the whole strategy to be abandoned. So you'd have like a repeat node. And sometimes you have a repeat until account or a time. There's many variations that you'll find in different specific behavior tree APIs. You will also see some that changed the return value. So you might perform a strategy and you don't care whether it succeeds or fails. It's maybe something that's just, it's nice if your agent does it. And if it is successful, that's great. But if it's not successful, that means don't interrupt the, say, a sequence. You don't want the sequence to be interrupted because of a failure on a non-critical behavior element. And so in that case you can have a succeeder. And so this filters any values that are being bubbled up through it to force it to always return true. And that avoids the implication of a fault being bubbled up or a failure being bubbled up because in the case of a sequence, it would short-circuit the sequence and it would fail, and you don't want that to happen. So these tend to be very useful for, especially when you have some recipe like a plan that has multiple steps. And occasionally, you'll have steps that could fail, but it doesn't necessarily mean that the whole plan is spoiled. So you just can say like return true. Very useful to use decorators as well in conjunction with the compositors. Then, of course, there's the leaves and these are the actual behaviors. So the terminal nodes in your behavior tree are associated with behaviors. As part of a behavior tree API, you will often have common game logic, this already implemented for you. So say if you have path planning or maybe steering behavior type movement, those you'll often find already in the pre-implemented behaviors. But certainly you can always implement your own. Often you'll find a object oriented approach, an interface perhaps that you can implement. And there's some key methods that need to be implemented and an initialization, and then a process or an update callback. And what this does is it performs a very brief calculation that is meant for a game loop update. So often as you might expect in a game, behaviors aren't immediately resolved in a single call. And that's because you have behaviors that can take many update cycles to complete. Say, a steering behavior may be following a path that was returned from a path search. So that could take some number of seconds before the agent finally gets to the destination. So in that case, when you parse through a tree and land on a behavior, most likely what you're going to have after you initialize and start the call is that it will make some little incremental calculations, like steering. And then the physics simulation or the character movement simulation will run just briefly for that little moment. And, of course, it's not going to be done yet, so the tree can't make further progress yet. So what happens is the update will return processing. So it's like one of three values. It'd be like success, failure, or processing. And so if it says processing, that means the next time the AI updates, we want to have that same node revisited because it's not done yet. So as the parsing of the tree occurs, each node will remember what child was being evaluated. So it will just very quickly land back on whatever the behavior was before that wasn't done processing. And it will get another opportunity to update and it will continue on it. It'll probably go for many frames. And then finally, let's say if it was following a path, if it gets there, it will return success. Otherwise it would return fail. And so then that gets bubbled up to the parent. And the parent might be a decorator or a compositor and then that would impact the logic, possibly with a compositor short-circuiting to break out and return a true or false. Or maybe all of the children have been exhausted. In a sequence, it's the last node to be evaluated in sequence. So you have all true, so therefore that compositor will then bubble up true. So each node has one action per tick. And generally, they're all going to just be making their recursive call down to, you get to the currently active child. And so that's the only one that actually is going to do anything. Most of the time it's going to bubble up processing, it's only when a certain behavior completes that you're going to change the current path through the tree. And so I think this would be a good time to look at an example because it's breaking a heart to think of this in an abstract sense. So this is the canonical example for a behavior tree, a burglar trying to break into a house. This particular scenario fits really well because the burglar has to have, say, a number of different strategies in order to get into any given house. Some might have the front door unlocked, some the door might be locked. It might be reinforced or not. There could be an open window, there could be a chimney and all these different possibilities. So in that case, we need to have different strategies, basically different contingencies for the ways in which the house might be secured. So our agent could represent a number of plans and contingencies with a behavior tree. And so this particular example has two key sub trees. On the left, we have one that deals with a sequence of behaviors to get through a door, and on the right, we have a sequence of behaviors dealing with getting through a window. And so you'll notice that if we assume this is red, top-down, left to right, we have the door strategy on the left. And I think that makes sense that in terms of the amount of effort that the burglar would have to put forth towards getting into the house. Door is easier to deal with than climbing through a window and so on. So let's consider what exactly would happen so that the burglar, say, arrives at the house, now they're trying to get in. We have a selector. A selector is like an OR operation. Conceptually, we can think about this as if the strategy in the first child, which is to the left, and that's dealing with the door, if that in overall ends up being successful, then there's no point in breaking into the window using the strategy to the right. >> If the door strategy fails, then we we'll continue to try other things. So we can have the next subtree that deals with window. And hopefully that would be successful. Skipping ahead, we could even extend this pretty easily if we wanted to add breaking in through the chimney. So we might have a whole plan that deals with, well, if you have a ladder or maybe like a gutter that the agent can climb up. If they can get to the roof, then can they get through the chimney. And so we'd have some pattern of behavior represented in a third subtree. And we could add more if we could come up with other ideas. But we'll start with the left subtree here. So when we go to the strategy for using the door, you'll see that there is a sequence that's involved. One is walking to the door, the next is doing one of a number of things to get the door open. We'll revisit that. And then the third step in the sequence is to walk through the door. Fourth step is to close the door. If all four of those children branches can resolve to success, then that means that it was successful, the agents successfully was able to get through the door. No longer do we need to worry about going into the window. So there's a short circuit at the root level selector and the agent is in and can move on to the next thing which would be bubbling up. So we can actually think of this entire tree shown here is really being a sub-tree of a even bigger tree. We're just focusing on this. And so that's a nice feature of behavior trees. And you can zoom in and focus on some aspect of it. So walk to door, that is a behavior. It takes some amount of time, so it'd be returning processing for awhile. It would eventually bubble up a success sequence. That is the parent would know at that point that it can move on to the next child. It was not short-circuit canceled. So go onto next child and you're now in the selector, first try open door, which would be working in the case of the door was accidentally left unlocked by the homeowner. That is like the easiest strategy to try. Probably likely to fail, but worth a shot. Low cost in terms of effort for the agent. The second child for the selector is a sequence and this is involving unlocking the door and opening the door thereafter. So if the agent is that able to unlock the door, perhaps has a key that they found previously, maybe they have a lock pick, something like that. If they're able to unlock the door, that would return true, and then we continue the sequence and then open the door. But we'll say that's likely to fail. So the unlocked door fails. We don't attempt to open the door in that case. So that bubble up to sequence, the sequence is short-circuit cancels. So that node now knows it's returning failure. Bubbles up to the selector. Selector still has a chance that it could work. So it's had two failure so far. So the final strategy to use it is the highest energy of the three, being the smashing the door. So break down the door. That could succeed or fail. In this case, we'll say that it's not a heavily reinforced door. So there's a success. Go to the selector. It is able to return success as well. Bubbles up to the sequence. Well sequence is not done yet, has had two successes so far. Third will be walk through door. Of course this is very likely to succeed because the door is no longer closed, is we've broken through the frames of the door, swings open with a broken door frame, and the agent can now walk through. And then there's closed door. Now there is one interesting thing here that is not reflected in this particular behavior tree and is the close door. If you think about in terms of the purpose of the behavior that the agent is performing, they're just trying to get into the house. Closing the door might be nice so that it doesn't bring attention to the home safe, maybe a police on patrol. They look to a house and they see a door wide open. And that would probably raise concern. Now if the door has been smashed though, maybe it won't shut anymore. So the closed doors strategy is something that I would say is advantageous to the agent to perform. But it's not critical to the task of going into the home. They might change your strategy. Maybe they spend a lot less time in the home because there's this evidence. And the loud noise they made and so on. Maybe they only spent a couple of minutes, so very quickly go in steal, whatever they're going to do. But maybe that would have taken a longer time had they not. But in any case, I could argue that closing door is not critical to the strategy. And so what's not shown here, and what would probably be nice to add is a decorator in the form of a succeeder. That would be put in line between the parent of close door behavior, which is the sequence. So in-between the sequence and the close door, we could add a decorator node called a succeeder. And so what that would mean is whether the close door succeeds or fails doesn't matter. If it's anything other than processing, it will be converted to success. But if it is processing the succeeder does need to return processing. So you don't want to return success for all possible return types. Is only the terminal return types that you would change it to success. So processing bubbles normally through a succeeder decorator. But if you get a failure, it gets flipped to success and success is passed through as success. So I would argue here that that is needed for this to be a more flexible strategy. And so you can do a similar thing. Maybe, for the right side, we can say that the smashed door fails because the door is reinforced. And so if that had happened, the selector would have exhausted all possibilities. So the parent of smashed door selector would have exhausted all possibilities, would then go bubble up to the sequence. The sequence now can short-circuit fail because it knows that it was unable to have success returned for all four children. That bubbles up to the root level selector. And now we can immediately jump to the strategy dealing with entering the window. And so you can look at that. I think it's also worthwhile. In addition to this example, just consider other types of scenarios that you might have in gameplay. One thing that's not really shown here because this is like a little isolated strategy for just a small part of what an agent would do. But you easily get into a situation where you're going to need control logic like looping, for instance. So you would have decorators that would just keep repeating something over and over. And there's also a few other things that quickly we'll run into that you might need that we're going to cover here in a bit. We'll revisit some of the issues that come up when you're dealing with behavior trees such as like being able to store something, or like parameterize. Like what are some parameters that you might need to identify in one node and then send on to another node. So we'll look at that in a bit here. But yes, I think this example especially gives a good introduction to the way that you think about structuring behaviors in a behavior tree. So I mentioned before that the strict ordering is very predictable with a behavior tree. Same fundamental problem that other reactive planning or decision-making strategies have. And so we can introduce the ability to randomize the behaviors by manipulating how the selector and sequence compositing nodes work. And really this just works on shuffling the order. And then we will want to have, of course, some persistence there. So when the nodes, first initialized, we would do the shuffle and preserve that across multiple parsing of the tree until we come back to the node again. So it's a similar thing to what was discussed with decision trees. So when you're randomizing a decision tree, you want to remember that whatever random decision was made, you got to preserve that until you leave that parsing direction, like leave that node and then come back again and then that would trigger reinitializing. So it's the same thing with the behavior tree. So pretty straightforward logic is just, instead of remembering a binary branch like in the decision tree, we are remembering our shuffling and resetting it when we leave and come back. >> Another issue that comes up and this is related to the issue of got this abstract decision making that's taking place and it's decoupled from game logic. And if we don't have that coupling, and this was covered in the finite state machine lecture when we looked at like the Xbox 360 commercial where there was the cab driver that was interrupted. So you had this disconnect between the expected behavior based on the decisions being made and the state of the game. And so this is dealt with in behavior trees in the form of semaphore nodes. So the semaphores it's like a way to keep track of resource use and lock access to the resource while something is being used and then return it. A common scenario would be a pathfinding. You might have some dedicated threads for performing, say, like an A-star search for agents. If you have a lot of agents, they will actually make requests for this limited resource. So one of the small number of threads for pathfinding calculation would be assigned upon request to an agent. And so the way that you build this into a behavior tree is with this semaphore. And so the semaphore node allows external resources, external to the behavior tree. You can unlock access to it. So that could be like pathfinding system, it could also be animation system. And so if you have a behavior that is tied to an animation completing and maybe dealing with some of the issues that were previously discussed related to the spin-off discussion from the Xbox 360 example. So this is the behavior tree way of dealing with that. Now another thing I mentioned before you might need to have one node that makes a decision and the results of that decision need to be passed along to other nodes. And in order to maintain the flexibility of a behavior tree, we don't want to end up with any tight coupling because that's going to limit the reuse of a behavior tree and it defeats really the key purpose of the behavior tree. So one strategy is that we can use a Blackboard. And so a Blackboard is really just a flexible shared memory structure that can be used to read and write values. And so it's from a symbolic AI strategy that you can define symbols that represent maybe information about what was observed from the world and then that is used to synchronize across different behaviors in a fairly decoupled way. So one behavior doesn't have to know about another. All it needs to know about is the type of information that it cares about that may or may not show up in the Blackboard. And so a common way that you might think about implementing this is with a key value pair in a dictionary. So in this example from the Millington book, we have a sequence so we have enemy visible. If that returns true, then we know where to continue the sequence. Next step we have a behavior that, the only thing this behaviour is doing is writing to the blackboard. And so it writes an enemy to the blackboard and then the next branch will go to a selector. And here we have some strategy involved in strategic positioning relative to the enemy and then assuming that is successful. We will then move on to, actually, this is structured such that it will always succeed. So whether or not it's able to get a more strategic advantage, it will continue. And you can see why this happens, because the final child, and the selectors always succeed. So that's like a variation of the decorator. But in this case, you might have a behavior that is effectively doing the same thing. We could easily switch this around such that there is a decorator in line instead. So that is like an optional strategy that would just be nice to occur. But back to the Blackboard, the final behavior is engage enemy. And so this relies on reading from the Blackboard. And so if we had it like a dictionary, we could have a key of enemy. And if it doesn't find an enemy then I would imagine that this behavior would fail if the Blackboard didn't show it. So this can be effective. Blackboard facilitates this decoupled approach. There's some things to watch out for, then you might have stale data. If you're not careful in the naming of things, you might fill up the Blackboard, especially if you had things like rather than just a single value like an ID for an enemy. If you had, say, a list of enemies, you could perhaps have things snowball. So you probably need some way to clean up the dictionary. Maybe additionally, you would need timestamps and things that get stale automatically expire. So there's a lot of little like peripheral issues that you do need to consider with a Blackboard. But the key here is this decoupling and the fact that it supports something that's like having parameters passed to your behaviors and not. We're avoiding cluttering up the structure of the behavior tree by approaching the sharing of information in this way. So just to wrap up. So behavior trees, they've become very popular. They've, I think you could argue that began to replace finite state machines. Like I believe unreal has a first class implementation like their own. It's not like a third party plugin was actually part of the unreal engine or their AI control has been used in many commercial games like Halo 2. And it's got many of the features you find of like a hierarchical finite state machine but also other planning concepts. It works well with sequences of behaviors without a lot of extra tracking information like that you might need to do with some other decision making strategies. They're really easy to design, especially if you have a solid library of pre-defined behaviors to the point that non-programmers can build these to have this nice ability to understand and read them just because the fact that it's a tree and there's no loops. They can easily be altered and reused parts of. You can even do this at runtime. I didn't cover this in the lecture, but you might be interested in Millington. They talk about some strategies for you basically using like a memory pointer type approach so you can have agents that are sharing different bits and pieces of trees. So you don't have redundant representation in memory for the game. They're just really easy to use and they also tend to fail pretty gracefully. The agents will maybe be taken advantage of by the player, but they'll still tend to select something to do. You may occasionally run into cases where you get in a bit of a loop where everything they try fail. So it looks like they're just wiggling back and forth between two possibilities but never making any progress but that's just really the same problem you can run into with the finite state machine. I think given these benefits and they're really no worse than any other reactive decision making but do have many advantages that has led to their growth in popularity. And so yeah if you're building a game, you might consider to use a behavior tree for implementing a reactive decision making strategy.
