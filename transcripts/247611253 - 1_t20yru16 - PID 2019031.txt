>> Hello. In this lecture, we're going to explore different search algorithms that we can use for path planning in our games. So we have previously talked a little brief introduction to path planning just to really set up the notion of creating a discretized space and that is allowing us to define a graph structure with nodes and edges on which will perform our search. So in this lecture, we're going to talk more about the searching. Just a little bit of review here. So we have previously looked at how path planning is part of formal planning in the sense that we have defined a state for our problem. And then we can apply operators to our state, meaning the current condition of, say, in the case of path planning, the current condition of the agent being at location A, and the goal of being at location B. So we can manipulate our state representation, which is our discretized space. And ultimately a graph. We can manipulate that through operators that move through the graph. Not actually doing the movement in the simulation in the game world, but just performing the planning. And if that's successful, you end up with a path that your agent can follow. So one thing is an algorithm that will make the appropriate selection of operators which are basically what are the different routes small pieces of the route that the agent should take. So representing our world with their discretize space. So far we've learned about the grid Lattice when we briefly mentioned other possibilities like defining waypoints with edges. So the grid lattices has a structure in the waypoints, is an unstructured graph with edges potentially varying length. And then of course there's other possibilities we mentioned as well. But the operators generally are always the same. Wherever you have a graph node, you can follow that edge. From a node, follow whatever edges it has to go to other nodes and hopefully end up at the right point. And there's two main techniques that we could apply. So one is the blind or uninformed search. This is where you have no domain knowledge, you know you have a graph that fits some defined structure of nodes and edges that connect the nodes. So all you know is what's the start node and what's the goal. You know, nothing about the relationship between the nodes and edges until you start to parse through the graph. Now in the case of a heuristic or uninformed search, we do have this domain knowledge. This is typically information that draws from the problem that the graph structure is applied to. So the fact that we have discretized from a 2D vector space, so like Euclidean space that provides for us the opportunity to leverage some information and will help us to have more efficient searches as we will see. So in terms of our look at path planning, this is going to be a bit constraint compared to maybe a more general AI study. We're going to focus more on what's most applicable to video games. And so that means that we're going to be interested in these virtual worlds that are static and of finite size. Now video games can break both of these requirements, but this is a good place to start. And certainly we could have worlds that are not static. But there's usually elements of most games that large static world with just a few moving objects, maybe like doors and drawbridges. But you tend not to see drastically changing worlds, certainly exceptions. And then also in regards to the size, it tends to be as the world's only as big as the artist, design it. But based on current trends, we've seen procedural content generation that could effectively be infinite. It might not actually be, but in terms of the impact on our path search algorithms, that would be the case potentially. But we're not going to consider those cases. We're going to think that we're going to have again static world with it with a finite size. And also our operators that we're performing as part of this formalized planning, they're all just agent movements and not anything that changes state, for instance. So that means we're not considering like pressure plates to open passageways in a castle, or needing to pick up keys or a push blocks around and make a staircase and anything like that. Some of those things are possible and can be addressed in planning systems for games. But again, we're going to focus on the static. So we're going to stop here, but then in the next video we are going to take a look at breadth-first search to get started in our look at algorithms.
