>> Hello. In this lecture we are going to consider the use of quadtrees and Voronoi-Dirichlet diagrams to serve the purpose of creating a discretized space to support path planning in a game world. So first of all I want you to think about the grid lattice and how that was a simple structure that we could use to facilitate path planning, but it had this problem of inefficient space representation because it always had that same resolution in the entire representation of the world whether you had large expanses of the same surface or traversability or very complicated details. It's always the same memory allocation. So it'd be nice if we could maintain some of the nice features of the grid lattice, but be able to address this memory concern and also the impact on the path search performance because more nodes means slower search. So the goal is to try to maintain simple convex spatial structure, but reduce the storage cost. The strategy we're going to use is we're going to try to use low resolution discretization for large uniform regions, but for environment details that are complex and affect the agent movement we want to use high resolution discretization around those areas. And so that general approach is what led to the quadtree, more generalized problem space, but the ability to represent details on a spatial level according to just the necessary amount of representation. So you might have say, a traversable area like a 2D map that's got different obstacles and you can divide the world up into regions such that some regions that are all the same type like traversable or not would be reflected in the largest possible region or only as small as needed to represent that. Now, in the case of the quadtree we still have a structured representation. And the structure is that you start with a big square region and then as needed for subdividing you break everything up into equally sized four square regions. And so any analysis of the world or the discretization process goes to this recursive process. Let's say you're performing the discretization, you would look to see within the root level cell which is as big as the world or as big as a very large tile in the world that maybe you would load in an entirely new one once you reach the boundary. So this would be whatever the working area or scene of your game is. And so in terms of building the quadtree as a discretized space representation, you would see if there is a difference of a mixture of traversable and non-traversable in the cell. So this might be a test of just seeing are there any obstacles within the cell? If there are then you subdivide down to four and then you test those for children to see if there's any obstacles in it. And if you get to the point where there's only one obstacle and the dimensions of the cell are entirely within the obstacle then you know that you've got a uniform area so you don't need to subdivide anymore for an untraversable space. And then for a traversable space you keep subdividing and recursing down until you just have no obstacles intersecting at all. So those would be the two different determining or terminating conditions to decide not to traverse lower. What you end up with is a quadtree. And so it's an actual tree structure with four branches at each level and the leaves tell you what type of material or traversability is in that cell at the very bottom. So this as you can tell only would represent just a subset of what a full grid would be which would be similar. If this tree was completely filled out every branch down to a certain depth would be like a normal grid lattice. But since many of the branches don't traverse all the way down because there's not as much detail in that part of the world that's represented, there is efficiency gains there. And so this, of course, that means fewer nodes and better search performance. Also it is a structure that is easy to manipulate. So there are fast edits that can occur. This is a video that demonstrates the use of a quadtree in a real-time strategy game. It's by the developers of Gaia Sky. I don't think it is a game. I think it is a planet simulator that can fly around the universe and check out different planets. But I guess the developers made this as a demo. It happens to be on YouTube and if you want to check it out further I've got the link in the lecture notes. But watch in the video you'll notice there's these different rectangles that the developer is periodically toggling on. So it's like a debug view of the quadtree. You'll notice that there are some big squares and some smaller ones. And also you'll notice that as the units are moving, say, a group of units moves into a large quadtree cell, it subdivides it further to represent where in the cell the various units are. So that's similar to what we saw with the grid lattice where agents occupying a cell could be marked untraversable and that would affect other units that are doing their own path planning or local movement. So these edits are all happening. You can see in real-time as the visualization changes units are moving in and out of large cells and the edits are fast enough to maintain this real-time performance. >> There's some challenges with working with quadtrees. Unfortunately, in order to get this variable resolution, we have to work with more complicated data structures. The grid Lattice was a nice flat structure, easy to iterate across cells. Look to the left, right, up or down or diagonal to figure out what neighbor cells are. In the case the quadtree, the neighbor cell problem is challenging. Especially if the cells are not in sibling. That would mean that if you're writing an algorithm to figure out neighbor cells efficiently, in some circumstances you're going to have to navigate the tree structure in order to find the neighboring cell. That's either directly working with the tree by working up and down the tree, or having some awareness of how a tree is stored in some other type of storage and then being able to jump to the right positions. There are various algorithms that I'm not going to cover, but you can research. If you choose to work with a quadtree, you might want to look into this particular problem, whatever algorithm you're working on, this leveraging the quadtree might need to know the siblings of cells. And so that's something you would want to be as efficient as possible. You can also potentially cash the neighbors. Another problem that arises is because you have the resolution that changes so much across the entire area of the quad tree, you end up with points localized in ways that it creates some weird structure and leads to really poor path quality, and it almost requires that you use post-processing just because the paths in practice end up being not so great. You can also get poor discretization of say, the geometry of your world. If your game world is say, something like buildings or long skinny hallways of structures as opposed to more of a sparse environment where you just say a desert or occasionally have some obstacles here and there, a few mountains and so on. You can end up having some high contrast obstacles. What happens is you end up with a lot of subdivisions of the quad tree. It doesn't seem like it's that efficient with space, even though the quad tree has this potential. Say you have a hallway or a room that lines up in just the right way so that it triggers a lot of subdivision just to represent the walls of the hallway or the room. You can potentially fix this if your game from the ground up embraces the quadtree structure. So in this case, you would actually be building your level geometry would be based on where the valid subdivision lines of the grid lines of the quad tree, where candles lines be. Anytime you have a long straight line, you want it to align with what the quad tree can represent. And so that will minimize unnecessary subdivisions. Next up, I want to show a commercial gain that used quad trees, and this is Star Trek Armada is a game that came out, I believe it was in 2000, so it's pretty old now. Is a real-time strategy game in outer space, but it's a 2D game. And it has fairly sparse environment, so this actually well-suited to quadtree representation. Of course, you can imagine that if you're in outer space, there are large open areas where you're free to move your spaceships around. But there are some things like black holes and Nebula that several of the I guess you'd call it terrain type, in this case just slow your shift down. So I think you can fly through most Nebula, but then there's some obstacles you just cannot get through, like space stations and black holes. But you can see that the interaction similar to like Warcraft 2 or dune and other real-time strategy games is just the artwork doesn't look the same. But yes, so they use a quadtree and so I'll show you a little bit of that. How they did it. Just a brief discussion. There is a paper you can find I've got in the lecture notes. The title, and I think I've got a link as well, you can find the paper for free online, which you might be interested in reading. But they show in the paper how they worked with a quadtree for performing their path planning. So they describe their algorithm and also have some examples such as these diagrams here. So they're actually based on the quadtree and built out according to the various train types and space stations and spaceships and so on that are in the game level. And rather than during the A-star search performing the neighbor determination which would be necessary for finding each of these edges. And that's how you would typically do things in a grid lattice, you wouldn't actually convert the grid to a graph. You would treat the grid as an implicit graph. And then just evaluate relative cell positions as needed while the A-star is performed. But in this case, in Star Trek Armada, the developers chose to pre-build a neighbor graph for the current scene, right when the search is going to be performed. They build out this graph and then work on that. So you can see the what was basically a path graph or path network. You see nodes which are placed in the center of each cell, regardless of what the resolution of the cell is, and then the edges connecting each. Then on the right, that is a demonstration of a resulting path where you have starting point A and destination B. Those get quantized to the graph. And so you see the little tails at the path that are necessary in order to get started following the path. And then once you get to the final cell to then go to the goal. It's a very inefficient looking path, especially starting point going way out of the way. So this is a circumstance where we'd want the post-processing or string pulling algorithm to be applied. Just at a high level. They have a solution that involves a combination of a star path planning. So they actually have a secondary a star process that identifies candidate nodes for the points of segments that are the optimal segments. And then they do a visibility test so that they can find where they have straight line paths between a minimum set of a path nodes. And so the final result is you get a cleaned up path that turns at inflection points relative to obstacles. This particular path is not completely perfect, it's close. So you can see that it does have this slightly out of the way where it goes from A to the second node and then it's the second to the third node and the third to the fourth node. You can see that it doesn't look too bad, but it's a little bit short of being the best it could be. And so there are other strategies for how to perform the string pulling. You can do some research if you're interested in looking at other solutions beyond Star Trek Armada one which is fairly straightforward. I think it's a practical one to implement without a lot of effort. Here's another one that I found on paper and honestly I haven't looked at all the details of how this one works, but just wanted to show you another example of what a cleaned up path can look like when a quadtree is used. So your quadtrees are certainly something worth considering. I would say especially for outdoor environments. I think quadtrees could work well for supporting path planning. Next step, we're going to look at Voronoi-Dirichlet Diagrams. These are interesting. They are very popular in computer graphics and AI and other computer science areas and all other applications. They've been around for a couple 100 years at least. And are well-studied and often they're involved in all algorithms. So these are regions that are closest to points in a set. I'm showing a 2D version. There are higher-dimensional like a 3D version, so we're just going to focus on 2D here. I'm not going to go super deep into details, but I just want to point out some of the ways, at least high level how they are used. So the regions which are these polygons in the figure that I'm showing, these different colored polygons, and. >> Any point within that color, you'll see a little black dot. And so within that colored region, all of the points of the colored region, the closest of all the black dots is the one that's within that region. So for instance, the top-left cell. You see my mouse cursor, that point right there. Anywhere in this blue area, the closest point is this black dot, not any of these other points. And If you pick any point along a boundary between two of these polygons, then it is equidistant between the two points that wherever the shared adjacency is equidistance between those two. So these are features that can be leveraged. So normally when you see a Voronoi-Dirichlet diagram, it is going to just show the single points are what's used for the test, for what's closest. But you can also have other sorts of shapes as well, which we'll go into in a bit here. But the single-point version works well to support path planning in games. But it generally requires manually placing and tweaking the position and possibly other aspects of the diagrams. So building a graph from the Voronoi region, the boundaries of these regions for the path planning meaning that the adjacent edges between these areas, those are going to be the edges in your graph and then the points where the basically the corners of the polygons, those are going to be your nodes. So if you look at at say, this particular picture here, you see that there's all these different line segments of the polygons, so you could use that for like a path network, and you can perform path planning that way. So this strategy works well for especially avoiding isolated obstacles. You can just drop a point on top. And as long as the polygon is big enough to contain it, then that will mean that the edges are away from the obstacles, so your agent can move around. Now the strategy often is coupled with adding a waiting factor so that you can have some of these points have a bigger area, basically. So it's no longer equidistant is the point that balances according to the waiting. So you can control the relative size of the regions in that way. So it's something you can tune. Now this doesn't work as well if you have hallways and other complicated like convex sort of shapes, you have to either, you might need more than one point percent, meaning that one polygon can have more than one point. So it still had the same color in this picture. But all the distance tests would be whatever point is the closest of the set of that color. But that can potentially break any algorithm that you're using that works for, say, like the one-point, you might need to revise your algorithm that generates this for you would be affected. And you could also possibly, if you have manually play single points, you might end up with edges that end up going through obstacles in your game world. You could also perform like a preprocessing or baking phase that would then delete certain edges that are invalid because they cross obstacles. So kind of a hybrid between a path network and then using these generator control points of the Voronoi diagrams. Now another approach is that you can use areas. So saw that with using more than one point belonging to the same color polygon. But you can have areas that you use for distance as well, so this is potentially more useful. Well, it says definitely better for automatic discretization. Because what you'll end up with is a line separating, like the line is furthest from any obstacle, or you end up with a path graph that where all the edges are as far from an obstacle is they can be. So that can be good for motion planning. So if your problem you're trying to solve is maintaining clearance from obstacles, there are maximizing distance from obstacles. Then this could be a good strategy. It could also be used for some problem-solving type issues, such as the piano movers problems. So imagine that there are movers hired to get a piano out of an apartment and it's really tight with hallways in rooms and so on, other furniture in the way, so how did you twist and turn the piano such that you can fit it through an area or even determine whether it can be done at all? And so the Voronoi diagram is sometimes used for that with offsets from obstacles, like shown here. But it is not good for giving you an optimum path because the best path tends to actually hug close to obstacles as close as you can get from cutting off corners, you're not trying to maximize distance from obstacles. So it's a functional graph in terms of getting two different locations in the game world. But it's not going to give an optimum path. So you're still stuck in the situation of the string pulling. So it might be something, it's really better if you are dealing with large vehicles or some kind of problem-solving that your agent is dealing with moving like a large structure. In terms of generating a Voronoi-Dirichlet diagram for the non-point version, for the point version as well, but you can use a modified version of this Delaunay triangulation to deal with obstacles of a certain area. And in that case, the modified version is constrained edge Delaunay triangulation. And so in that case, you mark the edges of the obstacles as being constrained. And then it'll build the Delaunay triangulation that's generated, which is basically a tessellation of this complex polygon. Well, there is a conversion you can do is very easy, is very straightforward to go from a Delaunay triangulation to the Voronoi diagram. So as soon as you have the Voronoi diagram, you now have defined graph nodes and edges that you can then perform the path planning on. And so just to close things out of the Voronoi-Dirichlet diagrams, they are apparently popular in game AI, in commercial games, I think this is probably more of the case a few years back to use them. But especially for the manual placement. I don't know about using the obstacle version to generate the pads that way. I've definitely heard about the use in robotics a good bit. But the two techniques that we've talked about with the quad trees and the Voronoi diagrams, both are interesting and I think that they are certain like game genres or applications where it's worth considering against the other space discretization techniques that we've talked about.
