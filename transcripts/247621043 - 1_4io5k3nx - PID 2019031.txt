>> Next step, we are going to look at quantization of game world points into the NavMesh structure, and also path refinement, what we've been calling string pulling. So let's consider we have some arbitrary point in the game world and we want to know where in the NavMesh it is. So we could work with the NavMesh itself to try to find the NavMesh convex poly, where that point is. So in terms of assessing whether we found our goal or not, rather than just by name, identifying a particular node, we would instead perform a convex point test against the polygons. Whatever the game world point is, project down onto the 2D plane if it's a 3D game. And that's what we're going to test against the boundary. So we could just exhaustively go through all of the NavMesh polygons and then eventually figure out which of the polygons it is or perhaps it's not in any of them. Or we could leverage A star search to try to find it more efficiently. So in this case, as we are expanding our search at the part of the algorithm where we test to see if the current node is the goal. It would be expensive in that we would have to perform this point containment test, but we can perform our heuristic. We know for each of the nodes of the NavMesh, we say have already selected where the nodes are, whether they're the centroid of the polygon or perhaps a center of edges or corners or whatever the strategy is. So as we're expanding the heuristic part of A star, we can say do Euclidean distance calculation. So the test point, we already have that in game world coordinates and we know where each of the nodes are in the game world that they have at position as well. So we can perform the Euclidean distance and that'll guide the search in terms of the heuristic component. And so we can continue to expand the search until hopefully we find it. So that would allow us to quantize the point into the NavMesh graph, but it might not be on the mesh. This is an issue that probably likely to face often with an agent. You are not going to have the entire game world represented by a NavMesh. There's also some inherent air with creating a NavMesh where often because of simplification of the world geometry and the desire to have a simpler NavMesh for performance, it's not a perfect representation. So you occasionally will have GameObject or valid game world positions that are not on the NavMesh. So you have to consider that as a possibility. So that would mean you would in worst-case be right back to searching all the nodes anyway and still possibly not finding it. So possibly a better solution in this case would be to use some other spatial partitioning scheme, such as a bin queue, where various GameObjects would be placed into something like a grid lattice cell, and then within each cell would be a list of objects, this queue. In terms of finding things that you want, some other object you can quickly figure out what cell it's in. And then you want to know things in the vicinity. Then you look in the neighborhood, which would be the adjacent bins or cells to try to find things. So you're quickly screening things based on axis-aligned boxes to figure out where objects are. So for instance, you could put the NavMesh polygons where it belong to these different bins. So if you have a game world point, you know what bin it belongs to, and then you also have its neighbors which would be in the same bin and possibly in the other, depending on how big these obstacles are and whether you store them redundantly across the boundaries or if you just pick one to store, in which case you might have to look in a neighborhood, but that's probably a better strategy. You could also similarly use a quadtree or octree to organize the NavMesh polygons to quickly find where they are in a particular region. That said, it's probably worth trying to avoid ever having to search or match points with NavMesh polygons. Anyway, at least where you don't already know where they're at. So for instance, if you're building a game and placing objects, you would want to go ahead and either have the NavMesh know where they are or have the GameObject know what NavMesh it belongs to, or have some lookup table independent of the two so that the agent, when it wants to know where to go, it says, I want to find the health power up or the collectible or the key to a door or whatever it is, they can just quickly identify what it is. So this would be something maybe that is automated during a baking process before the game even begins. Also, if you have dynamic objects that are being created, they could be created based on known spawn points. So the spawn points would belong to different NavMesh cells and that would guarantee that you start off with them in a particular place. If they're dynamic in the sense they move around, you would want to maintain coherence. Meaning that as the object moving is constantly evaluating whether it's still in the current NavMesh cell and if it crosses a boundary, say a portal edge of a NavMesh polygon into a new NavMesh polygon, you would update that information so that it would always be able to quickly look up without having to do any searching. So coherence with GameObjects that the agent is interested in is an important thing to consider and likely something you would want to implement in your own game. Next up, I want to look at the nature of paths that a NavMesh can generate, and the quality of the path and how we might be able to refine the path, especially in comparison to a path network. Here I've got a path network shown, overlaid on some height map geometry, and it's got some other complicated architecture and various elements. So we have our path network and as you recall, it doesn't fully represent area. That you might have a number of path nodes and edges that span a particular area, but there's no definition for a safe areas to travel. That is opposed to the NavMesh where we do have entire areas that are defined as being safe to travel for our agent. If we look at a path we get from path network, we can get a jagged path and this can result in strange behavior from the agent if it follows very precisely the path. Tend to see this as zigzagging movement where we've looked at in the path network discussion. If we wanted to improve this to perform string pulling, think about how this would be a process that would need to be performed during runtime. Unless we're precaching the common paths, otherwise, this would be something at runtime. With A star perhaps we've generated this path and we're about to return to the agent. If we're to clean it up, whatever that pulling process is, it has to look at the game world features like obstacles and other things that might get in the way of the string being pulled. So that's potentially unknown complexity to determine. Or we could have the agent have that greedy steering approach that we've previously discussed where the agent itself is trying to cut off corners. Again, there's a lot of reliance on the agent to be intelligent, to do so effectively. But with a NavMesh, once we have a path, we can refine that path within the limitations of the NavMesh itself or the constraints of the NavMesh itself. >> We have known structure in that we have connected convex polygons. We don't have some unknown game world features like terrain, height, and different surfaces and objects. If we've gotten as far as creating the NavMesh, these are areas that have been identified as safe for the agent to be located. So in terms of string pulling, when we're pulling the string, conceptually, we're pulling it against the boundaries of the NavMesh not the boundaries of the world. This is a far simpler structure than whatever complexity we'd likely have in your game world, so much more feasible to perform refinement to the entire path in real time. So during the point that the game is running, this is much more likely to work. And so one such algorithm is the simple stupid funnel algorithm, and it's really simple and popular approach. This version is especially well-suited to NavMeshes where expanded geometry has been utilized, and that is because the end result of the string pulling, of course, will tend to be right up against points of inflection, so right up against obstacles. So if you created your NavMesh with expanded geometry, going right up to the obstacle edges or the barrier edges of the NavMesh is really not the barrier of the world, is just how close the agent can get to the barriers assuming that the correct radius was baked into the expanded geometry and therefore the NavMesh. The way the algorithm works is wherever the start point is within a given NavMesh poly that is contained within, and you look towards the the portal edge that like say, a star or path search returned, so you know that the path traverses across that portal edge. And so you define say, looking towards that edge, you have a left edge and the right edge, based on the direction of travel. You want the agent to travel across that edge, and so you walk along the edges of the NavMesh that are not part of the path. This will tend to be barrier edges, but not necessarily, so you sweep the left side to follow the edge. The edges along the left side that are not the portal edges and keep going to each corner of the portal edges with consecutive NavMesh polys, and you do the same thing with the right side. So what you're going to end up seeing tend to be as shown on the slide on the figure on the right. You see when you start with A while, the the left edge is angled way to the left and the right edge way to the right, so left it is red actually because the perspective of the direction of travel would be going down, so from your perspective, red would be left and then blue would be the right. And so you say, well, it looks like it starts with blue first, which is the right side, so you move down that edge to the next portal corner and then you move the red down to the next portal edge corner. You'll notice that it's like a flashlight or funnel, as it's called. It's getting narrower and narrower as you parse out further and further following the convex polygon edges down to the next portal edge. Eventually what happens is you get the funnel is so narrow that in order to continue going, the right edge of the funnel crosses over the left edge or vice versa. When that happens, that means the point you just crossed over, that is the next point. So you might go across several NavMesh polygons and sequence of the path before you finally hit a point of inflection identified by the funnel edge is flipping over to the wrong side. And then you start over with the algorithm again. So you then from that point, look at the next portal edge and that defines your left and your right, and then you move along based on those non-portal edges, and you're going to start with the one that does not have say, two portal edges coming out of it. So the free side is the one that moves next and then you go to the other side alternating. And just keep going until you get to the goal and you will have identified a sequence of points that will be the path that you're going to return. Now, again, this really depends on having expanded geometry, assuming you have an agent that would takes up space. Now, when you are using expanded geometry, we're thinking in terms of just a point. That's why this works, you can get the agent right up against these points of inflection. But there might be situations where you don't have expanded geometry. So I'm going to show you a variant use and Horizon Zero Dawn. The reason why they don't use expanded geometry, they actually generate their NavMesh at runtime. That's because they had this huge procedurally content generated world. They have the robo dinosaurs of vastly different dimensions, so they build out appropriate NavMeshes based on the different the dinosaurs, so some just ignore obstacles because they can destroy them, just walk right over and destroy them, others have to move around things. So they really need custom NavMeshes. But they don't do expanded geometry because they want the building of the NavMesh in real time to be as performant as possible. So they use a variant of the funnel algorithm that is very similar, but when these points of inflection are generated, it creates an offset from these points to basically serve as the offset of the point of inflection. So in very similar algorithm it looks familiar. You advance either the left or the right side according to whichever side has a free edge to follow, and when you have the crossover, like shown here, so we advanced the left side twice because that was the free edge side. So it crossed over. That identifies the point of inflection. So now what you do is rather than just saying that that is the point, you then determine a line on which to apply the offset. And so this is calculated, I believe, from the normal of two. The current path of the agent is the left side, it's not the two sides of the NavMesh. The blue edge on the left is determined by where the agent was previously, like in the ongoing progress at the string pulling, and then using the side edge of the NavMesh polygon and consideration. So that determines the bisecting line, so you can take the average of the two normals of those two directed edges and then use the radius of the agent as the offset, and so your point of inflection is now placed at an appropriate offset and can't continue on from there. And so it's really the same algorithm as a stupid simple funnel algorithm, but just as extra offsetting calculation. And so that will get good results if you do not have expanded geometry. So you're hopefully beginning to see that there's a lot you can do with the NavMesh structure. It's not just to create you a path network and then forget about the fact that you have all those NavMesh polygons. These polygons themselves are very useful for other calculations related to movement, including the string pulling that we just looked at.
