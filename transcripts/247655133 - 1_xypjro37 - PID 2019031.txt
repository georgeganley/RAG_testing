>> Hello. In this video, I'm going to give a demonstration of the procedural content generation assignment. So in this assignment, you'll be working with Perlin noise as a way of creating hype map-based terrain in unity. Let me switch over. This is the project that is on GitHub for the assignment. I believe when you first clone the project and open it you'll have the same problem as usual of a default scene being there. She actually need to open the correct scene, already have it open, but just as a recap what you want to do is go look in the project view assets and then under scenes, open up PCG terrain that is the starter scene for the project. Now, this assignment is unique compared to the other assignments that we have worked on in that you will not be writing procedural code instead you will be creating a declarative specification for rules that define your terrain. So this is built around a feature that is built-in to unity. This is called the terrain. So I've already gotten this scene everything set up. It's got this manager which handles some basic interactivity for the project allowing you to if you run the game, you can fly around, you can also hit Escape to quit the free look camera rig. This is again, only when you hit Play a light, and then the most important part is this terrain object here. Now, the terrain object it has a terrain and a terrain collider. These two components you get if you create a unity built-in terrain. So you can do that if you were starting from scratch, for instance. Let's see if you can right click create and then if you picked a terrain, it would make an object just like what you see here, this big rectangular grid. And the game object would include the terrain and terrain collider. It would not have this PCG terrain, so that is the script is provided for the assignment. But this terrain normally without procedural content generation, you manually manipulate the terrain and you'll see in the component there are some little icons, and you can pick to do things like use a paintbrush and you can paint the terrain. And so you're literally painting changes in height. And certainly that is a viable way to create terrain but it's also tedious, takes a long time. So it'd be nice if you could just generate the desired terrain you like. Want to go ahead and point out some important features with this terrain object that will be useful for this assignment. So there's a little gear, few mouse over. The tooltip says terrain settings. So if we do that, we'll expand the settings and the most important items I think near the top under basic terrain there is a material if for artistic or aesthetic purposes you want to change the material, you can do so. I've already included in the project a number of different materials if he hit the little read out button, it'll bring this up. And there's several in here that aren't really appropriate but you'll notice there's these stone patterns. Those are some that I imported. I think there might be one or two others with different names that are in here. But a lot of these other materials come from other assets that are in this particular project. So yeah, I think mainly the stone, I believe if you look under third-party in the project view, you'll see that there is the under free, there's a desert rock, and then I've got the stone textures package. I think those are the main sources that you will be interested in. Let's say, good for the material. You probably want to stick with the current texture at least while you're editing, and then when you want to say create screenshots, then you might switch the material. It's sometimes hard to see exactly what height map features you're generating when you have a complicated looking material. The other thing that's useful is, if you scroll down to texture resolutions, there's one in particular that you'll probably want to manipulate and that is this height map resolution it's got a drop down. And I believe what is posted on Git will be 513 by 513 height map. If your computer doesn't perform very well, I recommend dropping to 257, like if there's just too much lag in terms of the manipulations that you're going to be doing, then try dropping that down and the the rules engine will recognize the change and update everything. And then when you go to say the point that you've completed your terrain, you might switch to a higher resolution so that you get more detail like in your screenshots so when you're done. The way the engine works is that it only processes when there are changes to the rules, so once it's done processing then everything's on the GPU in terms of loads, so the number of triangles in figure most people can easily handle a higher setting. One downside in terms of editing when you have a lower resolution height map is that, if you have really high frequency noise to create like say, fine-grain texture which we'll be learning about shortly how to do that, but it won't show up necessarily in a low resolution height map, so some of the finer grain details will not show up unless you have a higher resolution height map. So there is a trade-off there in terms of editing. I'm going to leave it at the 513 by 513. And by the way, it has the extra plus one pass a power of two texture dimensions because the way the height map values fall relative to the graphics texture. So they have to have to add this one extra unit in order to align properly within the tiling of the textures, it just works out where they need to have that extra unit. Don't think you'll necessarily need to change anything else unless you're just trying to get better lighting or something more related to the way it renders. >> You don't really even need the terrain collider because we're not using it for gameplay. But yeah, other than that, you can pretty much ignore the terrain. Again, that is a unity provided component and so you'll mainly be using this PCG terrain. So I'll talk about this now. So you do have the source code for all of this by the way if you're trying to figure out exactly how something is working. But this object [NOISE] or component, it allows you to control and constrain the way that noise is generated. So we're leveraging something called Perlin noise. And Perlin noise is a type of gradient noise. That means that it's not like white noise where you have information at all frequencies. Instead, it's limited to a certain range of frequencies and there's a smooth gradient between the different values. And so this is really nice for creating natural looking features derived from a random source. So I'll show you a little bit of what this can do. So the simplest thing is that the PCG terrain component can request noise from a Perlin noise API and then we can control it. So the main values that you'll be using, there's one called a Perlin scalar. Hopefully you can see that in the video here, so the Perlin scalar, you can think of is like a zoom level on the noise. And then there's this max value. And the max value controls how strong the contribution of the noise is. So if I move the scalar around, nothing happens because the max value is currently at zero. But if I bring the max value up, so the Perlin scalar at zero, it's like infinitely zoomed in to the point that there is no noise source. But you can see I can move from 0-1. This is the full range of unities terrain. It has a normalized value, 0-1 height. So that's the maximum range of height values that you can set. So the terrain height map is simply a 2D array. It's like a texture except the values of the pixels are the heights. And so this terrain is made up of lots of little triangles. We're just not seeing the triangles because all the heights are the same currently. But let me put it let's say halfway and then I'll start to play with the Perlin scalar. And so you don't have to move it very far and you'll start to see that we're basically zooming in on a pre-computed texture. And of course, if I keep pushing it, it'll look more and more static. But if we're on a lower level, we have these nice smooth transitions between the two. And now if I play with the max value, you can see these changes. So what's happening under the hood is that we're calling upon a Perlin noise generating function based on offsets that are relative to the 2D coordinates in the control texture. So whatever the terrain dimensions are, get replicated to an array of values in this particular component, this PCG terrain, and then we just pass through or loop through each of the pixels, and then we do a relative offset into what the Perlin noise generating function gives. And that's controlled by this purlin scalar, how far zoomed in we are. So at a high level, it's really pretty simple what is going on. So right away, we can get some terrain that looks somewhat interesting, maybe like sand dunes. And the other thing we can do is we can control a fixed offset for the terrain generation. And so if I pick one of these dimensions here, and you'll notice I have x offset and y offset, and these have 1000, 100, 10, and 1. Basically, the reason why there's all these different levels is so that you can control how big an effect the slider has. Unfortunately has a really tiny resolution relative to the full size of the editor. So if I had a really large range of offsets and you try to slide it, you wouldn't be able to move in tiny increments if you wanted to. So if you want tiny increments, you can pick x offset 1 and then you can move that way. So you can immediately see the changes update on the screen. So this shows how the terrain might be generated if we expanded it a bigger than the small patch of terrain we had. So this could continue on and on forever. Eventually it repeats. But you can see that it has a nice smooth transition through different values. And if I want to go further, I could pick a different value and see how it moves a lot quicker with a different range of values. So these are just taken as a sum together. The offset of 1000, 100, 10, and 1 are all added up, but you can tweak them as you see fit. The same with the y, just moves in the other direction. So this particular implementation of Perlin noise, it also has a z offset. So you can think of it as a 3D space. I don't have all the offsets there for the z offset. Even though we don't really need this feature, this just is another way to add some variation if you choose. So it just got the one slider value, but this one makes less sense, at least in terms of say tiling terrain, you would probably have the same z offset for everything. >> That covers most everything you need to know about having a single node of the terrain generation. So all of the features related to a single node are really this drop down gene noise type. Now, I guess there's one other thing I haven't mentioned. And that is you can filter your Perlin Noise through a mapping curve. So if I select that now, this introduces some extra overhead, I'll probably see you. It's updating more slowly now is my guess, can't tell too much. But what that is doing when you select Perlin Noise with mapping curve, you can apply a function to the evaluation of your noise. So whatever as input you provide an x, y coordinate, to this x offset and y offset, and then also the z offset that is given to the Perlin Noise generation function. What would the scalar and then spit out a value and that's multiplied by the max value to set how strong it is. But before it gets applied to the terrain, you can send it through this function. And so there is this actually unities Curve Editor. Let's you define a function shapes. So you could remap, say a y value that's returned a Perlin Noise value that's returned is an input along the x axis and we can map it to a y value here. So we could do something like that and you can see the change hopefully in the video behind. We can manipulate exactly how the noise is generated. So this gives us a lot more flexibility in how we can generate even within one node. So if you are going to manipulate this gene noise curve here. Just be aware that it will have no effect unless you change this drop down from Perlin Noise to Perlin Noise with mapping curve. And the reason why it doesn't just always use the curve is because of the computational overhead. So you have to really want it to and then turn it on. You could also set to none. That's really only useful for when we talk about adding hierarchies to the rules. So generally you'll have the Perlin Noise on and you'll have some settings set here. So next step, we can consider creating a hierarchy. So with Perlin Noise, you can actually layer Perlin Noise on top of Perlin Noise and create even cooler PCG effects. And typically how this is done is you have say, Perlin Noise at a base frequency. And then you apply octave of the Perlin Noise with diminished amplitude. But this particular tool, it doesn't impose any constraints on definitely having the octave multiples of the frequency. So it's just up to you to set it. And also there's no constraint on the amplitude either. So if you're already familiar with Unity, you're probably normally think of creating objects by using, say, Right clicking and then doing Create Empty or create whatever you want under each object in the terrain. But for convenience and actually highly recommended that you use the automation provided to create new nodes, because there's a lot of things that need to be set up correctly. So if you want to add another node and so you can create layered Perlin Noise effects. Use the Create button down here at the bottom. So if you have the terrain object highlighted, scroll to the bottom, click Add Child PCG Terrain Node. It will create this new node, this added here. I recommend you change the name to explain what it is you're doing. So you want to change it in this config region here, not up here. So this is normally where you have the name of unity object. But instead, the way the script works is that this always overrides that and they'll synchronize those. So I'll call it TerrainDetail1 I guess. You can see that it changed up here. So I can make that change now, right now the Perlin Noise here is very small, so we're not seeing much of an effect. But we can increase the Perlin Noise scalar to get a high frequency. We can't really tell much at this point because the magnitude or this max value is very high. So if I scale this down, you can then maybe tell that it's layered on top of the noise at the root level, which is this object. So this object called terrain has a purlin scalar is 6.1 and the max value of 0.225 actually let me crank this up a bit. Alright, then this TerrainDetail1 has 30 for the noise types, a much higher frequency is the resulting effect. But I crank down the max value a good bit. So you can see that it's additive with with its parent. And I can move around here. Give you look at the terrain. So you can see now it's looks like, I don't know, maybe a bumpy surface on an asteroid or something like that. And then with the terrain detail, of course, we can play with the offsets. So I can slide things around. You can see that it changes, changes the texture on top of that lower frequency. And then one cool thing you can do is if we go back to the parent. So the hierarchy is designed in such a way that the offsets build on top of each other so you can have everything moved together. See how it looks like we're doing a flyover now so that the high frequencies are locked to the low-frequency features of the terrain. >> And we can even go further. So we could add some even higher frequency details on top of that terrain. So I'll go to add a child again. So I've selected the second level TerrainDetail1, and I'm going to click Add Child PCG Terrain Node, which is at the bottom of the PCG Terrain Script component. And I'll call this, give it a name. And we'll call that TerrainDetail2. And then I will pick an even higher frequency, and then pull down Max Value. So I think we're reaching the limits of the texture resolution, where you can see that it's now evaluating that. And if I go back to the root and play with the Offset, you can see it all slides along. But now it's computing slower. The frame rate of the changes is dropping. Let see, hopefully this works. I'll try to change the resolution and see if there's any detail that pops up. Of course, want to change the resolution of the texture, the frame rate is going to drop even lower for any changes made. That actually didn't have much of a change, but maybe if I go higher frequency here. There you go. So it can get really bumpy, but it's not super interactive, but this is effective with this particular resolution. I think that covers the basics of how to create a hierarchy. Well, actually, I forgot to mention these drop-downs. So with these drop-downs. Once you have a hierarchy that there's a way that the nodes are parsed. So the first step is the noise. Noise is generated for a node. But then that noise is generated can be processed by a child. So for instance, TerrainDetail1 can manipulate its parents noise. So there's a recursive call, and then the child has an opportunity to manipulate that noise. And so there's two parts to that cycle. One is that the parent can be reinterpreted. So normally if I want to just do a pass through. So that's just taking the values of the height map values as provided by the parent. And then there's a combination type. So this means for whatever the child node generates for its own noise. How does that get combined with a parent? And so most of the time you probably want to add and just pass through the parent and add to it. But you could choose to do these other things, like maybe apply a custom function. There's this trapezoid function and a mapping curve function. You can also take the compliment of the parent or just zero out the parent. And there's also this image processing. So I'm going to say that for a more advanced video. Within the combination type. There's Add, Subtract, reverse the order of subtraction, Multiply, Minimum, Maximum. And then there's these different normalize and then there's Replace. And so these allow you to control the way in which you add together. So probably Subtract will be popular to use. Let me switch to a lower node. So we might subtract. And in this case that's just the nature of the details, like the texture. It doesn't look any different, but it did drop in height when that was applied. Let's switch it back to add. There is a possibility that you can run out of resolution, which you might have thought of when I told you that terrain can only have a value from 0-1. Let me just go ahead and cause that to happen. So this TerrainDetail2, if I generate a really high value, I should hopefully clip. It is clipping, but actually it's so high frequency that it's hard to tell. Let me do the other node. So I'm switching to TerrainDetail1, and then let me try increasing now. So now you can see the clipping a lot easier. See those little flat plateaus there, so that is where we clipped. But if I changed, add to normalize from parent to top, then what happens is that it's taking the generated value, this child node is generated noise. And it's remapping that to whatever the peak was from the parent up to the max range, which is one or at the top. I call that top, but that just means value of one. So it just does like a linear interpolation from wherever the parent value currently is up to the top. And that's to avoid this node causing clipping. And actually probably still have a little bit of clipping if the string Detail2 happens to add on top of the normalized value from this node. So you could also put a normalized from parent to top here as well I believe. And you can see that they shrunk a little bit and so none of these nodes should be clipping because that is used. So if you're having clipping problems, you might want to switch to that. >> Again, the processing that takes place is that each node generates its noise, but it has to first check recursively if the child node manipulates it in some way. And then if there are no children, of course it uses the noise it generated. If there are children, then it takes the sum of all the children generated values, which take as inputs the parent noise. Then the node in question is actually figuring out its own contribution to parent. So of course if it's the root, the contribution to parent is there's nothing there to do because it is at the top level, but any other node will generate its own noise, figure out the contribution of children, and then relative to the parent, that particular node will figure out if it's processing the parents like manipulating in any way. Usually it's passing the data through, and then it's combining with the parent and then that gets returned to the parent. So it's a bit confusing at first because of this recursive logic here. But it ends up being a pretty powerful approach to working with it. You have all the code for this. If you're curious, you can check out the code. Most everything that's interesting is in PCG terrain. The highlights are, there is applied Perlin noise. So this is the actual method that generates the Perlin noise and applies it to an array, and these, when possible, everything is cached and reuse so they don't have to recalculate everything to the logic for generating the rod noise. Then there is this process function. This does the recursive logic. If you check it out, you'll see that there's the first stage of generating the noise. So this is the noting questions contribution to noise. Here's the call apply Perlin noise so that generates that texture, then if there are children, this next phase here, we'll call each of the children. So the child process, the child gets to generate some noise, and then after all those contributions are added together, so just adding the different generated array values, then there is the processing of the parents. So if there was a parent, then it gets processed. Again, it's most likely going to be passed through, but there are other scenarios where you do differently, and then after the parent is processed, it gets combined. So you see there's these very simple operations like add. The parent matrix or array gets added with locally generated noise, which might have been influenced by children, if there were children, and then it gets returned, and then if it's the root node, it gets applied towards the terrain height map. The root being here, we would just apply it to the terrain. We now have a basic terrain. Let me bring this back down to a lower level on just this one. Bring this back down. Here is our terrain. Now if we want to save this, this is actually using a feature called the scriptable objects in unity. The particular object is saving to is this PCG terrain data, and that happens to be under student work already made for use of this PCG terrain data is here. We can't save it. So you'll see there's some settings down here at the bottom. I've got the root object selected. These will only show up in the roots, the saving and loading. But we can click "Save." And by the way, be careful with these, there's no user-friendly error checking here. So if I click "Save," it will have saved to the scriptable object. Now you can click it and look at it in the inspector and we'll see that there's the terrain object, terrain detail 1 and terrain detail 2. So those are all of the objects we expected with their various settings. Then that file. See if I can share this to you. Just a second. So this is an explorer. I just did show an explorer and so that's the file, I opened it. We can see what it looks like. So this is YAML file format. We can just confirm that it's got everything saved so we can see that there's the terrain object, terrain detail 1 and terrain detail 2 with all the settings that we expect. Of course, we could maybe check some of these values if we wanted to confirm. But that's the only asset that you have to submit when you complete your work will be that file, and then of course, your screenshots that you take. But you can also, I'll make a separate video for creating new terrains or perhaps swapping. Like if you want to make multiple versions of terrain, you can make multiple of these scriptable objects, but I'll make a separate video for that. This covers the very basics. What I've explained so far isn't a complete description on how to do everything needed for the assignment, but it should hopefully at least get you to the point where you understand some of the basics and can start playing around. I'll make some more advanced videos as well.
