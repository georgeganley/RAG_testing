>> To wrap up our look at holistic projectiles and games, we're going to consider some practical issues that come up when you're trying to implement these algorithms. Just writing the algorithm itself is really pretty straightforward. There's not a lot to it, especially if you already have the algorithm defined for you. What is a challenge, though, is actually putting it to use in your games. It is really going to vary with your game, how this works. So at the end of the lecture, there's going to be a separate video that's going to have a little hands-on demonstration in Unity something I wrote a while back has a character that throws grenades. One of the things I had to deal with in implementing that is, the projectiles aren't just launching from some random position, like in the shooting gallery that we saw in the previous examples. Actually, I want the projectile to look like it's being thrown by a character as an animated 3D mesh character. It'd be pretty obvious if the grenade is just flying out of his chest or his head or something. I want it to come from the hand. So that's straightforward to figure out where the hand is. I can just attach something like a position. I can track relative to the hand that's available to me in the game engine. And I can also measure where I am in terms of animation. With an animation callback, I can say, okay, well this is the perfect moment for the grenade to be released. So the animation system says, hey, the hand is in just the right position. It calls my callback. And that's when I can spawn the grenade to go flying into the air. So that's all easy. But the problem is, think about in terms of your agent deciding at once to throw. So it's decided it wants to throw, but it can't throw yet because it relies on the animation of throwing for the grenade to actually be released. And that's sometime in the future. A very short time, but it's in the future. In my case, it was like, I think a quarter of a second, that's how long it took for the character to handover, the shoulder, elbow forward, and then start to do the release of the release point of the throat quarter of a second in the future. So that meant that any prediction I was doing had to be delayed. So in terms of trying to hit a moving target. In this case, there is a Minion this running along and I want to hit it. I have to do the prediction delayed start. So that added some complexity. It took a bit of work to deal with. But also predicting where that future position is more than. So my character can run around while throwing. So I have to extrapolate where the character will be in a quarter second while running. And then where the hand will be relative to the character and the character can lean left and right. So I tried to come up with an approximate way to deal with that just based on the average running speed of the character. And where the hand is relative to the root of the character, which is down on the ground in immunity that they reposition, it's actually projected from the hips down to the ground. It's at the bottom of the capsule collider that's sliding around. So that took a bit of work to make sure I got that set, but it's still not perfect. Especially as we'll see when we discuss some further things that are good to do. So dealing with animations adds a lot of complexity, even though, again, the throw algorithm itself or the calculation for the trajectory is very straightforward. It's just a few lines of code to implement. But in order to actually get to the point where I can call it, took a lot of setup to deal with throwing from the hand delayed from the animation. So you might also consider some gameplay situations. In the shooting gallery, we just shoot all the time at a very high rate. There's not like an AMA limit. It's not even a game. It's just a little demonstration. The agent though in your game. So whatever game you're implementing might have valuable ammo that needs to be used sparingly. So in that situation, we don't want to waste. Like I say, you only have a couple of grenades, you don't want to waste them. It could also be that whatever the animation is for launching or throwing the projectile, like it might be a gun that takes a really long time to load, even if you have a lot of ammo, the agent just can't be shooting at low-probability shots. So we can implement a heuristic for deciding when to throw. Don't throw if conditions are bad. You want to consider things like, Well is the target at top speed? If the target is not at top speed, it's probably accelerating because in a video game, if you're not going full speed, you're probably accelerating towards full speed or decelerating to a stop. So it's usually very little in-between. That makes a good heuristic. If the target is probably turning to a new heading, it's not going to just keep turning all the time. It's going to turn and then it's going to run straight at whatever the next thing is going at is. If it's turning, just hold off, and if the target is or happens to be on a navmesh, you can check to see if it continues on its current course. And let's say you solve a t-value for collision. So you could say, with the current position at target, we're going to extrapolate from there and just using assuming constant velocity. Well, if that hits the edge of a navmesh, then it probably isn't going to continue going that way because it'd run into a wall or something. There's no point in trying to throw there because then you're just going to hit a wall. So you can re-cast along the navmesh to figure out if by the time your throat would get there it would hit, then that means the target is going to move. And you can just say, well, I'm just going to lay off. I'm not going to have my agent through. You can also check if your projectile is predicted to hit something sooner than the target intercept time. So you could say just simulate throwing it and see if you get an intersection of the line that's formed by the throat. Then lastly, you can consider, well, do you know your target's goal? If it's a human player and they're trying to go grab the pot of gold. And your agent is throwing bombs to stop the player from getting there. Well, you can anticipate that the player is probably headed towards whatever the location is, like the pot of gold. There's lots of heuristics you might consider that will influence the throwing behavior. As for dealing with the weather, a projectile is going to hit something else before it hits your intended target or you're going to have to deal with lobbed projectiles which are under the influence of gravity. And so that means you can't just do a single re-cast at least. But you probably also don't want to calculate the intersection of this complicated curve equation with all of the different obstacles that may or may not hit. We really rather stay linear if we can, because we're trying to maintain real-time performance. What you can do is you can approximate the parabolic arc. You can calculate what the peak is of the arc, assuming there is one, because your agent might be throwing straight down if they're up high or something. So you'll have to check for that. But if there is a peak that is reached, we can solve that. We can re-cast to the top of the arc and then from the top of the arc down to the target. If we don't get any hits on either of these two re-cast, then that means it is unblocked. We might try to break things down further because just breaking it into two re-cast, you will be well under the parabola shape. So you would say miss hitting something that actually would collide, that would be above the line. So that may or may not be a problem for your game. You could break it into say, four segments and get something much closer. Or how many ever segments is important for your gameplay. One other thing is you could, perhaps in your games, allow projectiles to balance. Oftentimes, they just blow up as soon as they hit anything. But maybe it's like a grenade that will eventually blow up and you can actually skip it to the target. That would be some added complexity to modeling and prediction if you were allowed to skip the projectile rather than having to stay in air the whole time. Then all of the approaches that we looked at, at least in detail. The agent was always throwing at full speed. But what if you could have the agent throw at different speeds? And I think most games that do allow this don't actually calculate for arbitrary adjustment minutes to speed. They might calculate once for full speed, then once for medium, and once for low. So we have these three different hard-coded levels and so you're not actually considering all variations between. Lastly, there will be an additional video as part of this module that'll show much of what I've talked about in action. It doesn't work perfectly. But I did try to implement some of the heuristics that I just talked about.
