>> We're going to look at launching a projectile that's affected by gravity and launching it towards a target that's fixed in position, our static target. And it's going to be a 3D position. Again, assume that we have 3D positions, the launch position is in 3D, the projectile it's going to move in 3D. Then we're trying to hit a target, but this target is not going to be moving. The projectile again is affected by gravity, but we're not going to support drag, there's just particle dynamics without drags, the typical movement where you consider velocity and acceleration for the projectile. So we'll have the initial velocity and the acceleration due to gravity. We're going to assume also that the projectile is always going to be launched at full force. There's not going to be any attenuation of the amount of force applied. That's going to simplify things a bit for us. Really, all we're solving for is the direction of the velocity because we already know how much we're scaling that being the maximum speed at which the projectile is going to be launched. I have some definitions for variables here we have P_t, the position of the target. Again, this is stationary. The initial projectile position. We have a vector u, which is for the direction of the projectile at the launch. So this is the direction part of the velocity. Then we've got the speed, which is just a scalar, that's scalar times U_p, that will give us the full velocity. Then we've got gravity. And we are also concerned with a time value. So t_c time of collision. What we're going to be doing is solving for vector u_p. That is the initial direction of the projectile at the point that is being launched. The point that the projectile is gaining an instantaneous change in velocity. That's the ballistic part of the trajectory. From particle dynamics, we have seen before that you can figure out the future position of particle based on the amount of time elapsed if you know the initial position, and you know the velocity. So it'd be original position plus velocity times time plus 1.5 acceleration times t squared. Our acceleration is gravity, the gravity vector, it probably will just be the y-component of the 3D vector is going to have negative 9.8 meters per second, or it could be other values as well. Our velocity, in this case, we're replacing the V with our u vector, which is direction. So it's a unit vector times the S, which is the speed of the max speed of the projectile. Multiply that times u and that will give you velocity. So that will be time to time. So this equation should be familiar. And we can break it apart into three separate equations. But we have unknowns for the u vector which includes our ux value, the uy value, and the uz being a 3D vector. So that makes three values of three variables. And then there's also a fourth one we don't know, and that's the time of collision. That's the problem because we've got three equations so far. So we need a fourth equation to be able to solve the system of equations. Luckily, we do have one and we can get that from the fact that we know something about our u vector, and that being that it is a unit vector, that means that its magnitude is equal to one. Using the equation for magnitude, we would know that that would mean that the square root of the sum of squares of the x, y, and z terms, that would be equal to one. Since we've got the equation set equal to one, we could just take the square of both sides and know that the one will just stay a one so we can just get rid of the square root, which is a nice thing to do generally anytime you're trying to compute a solution with a computer, you want to get rid of this square roots. We go back to our equation for motion. Being able to solve a future position of the projectile based on the initial conditions and the elapsed time. We want to solve for u, again, that is the direction that we're launching our projectile. We can isolate our u vector and we'll get what's shown on the slide here. So you got the position of the stationary target minus the initial position of the projectile, or the launch position. And then minus the half gravity times squared over speed times the t. So we can substitute for the relative position vector. So the P_t minus P_p, that, again, being the target position minus the initial projectile positions. Subtract this, that gives us a delta. And that cleans up our equation a little bit, will help us in the future here. We can plug into each dimension of the u vector into that fourth equation, if you recall, we had the magnitude of u is equal to one. We can break that down knowing that it's the sum of the squares of the x, y, and z terms. >> Since we've just now solved for you, we can extract the x, y, and z terms as shown here. I've only got the work shown for the x term, but it's gonna be exactly the same with the y and z, just the subscript is going to change for what's being referenced. So in this case, like we would have the initial launch direction squared for the x term would be, the x term of the delta minus 1/5 g the x term of that, times the atomic collision squared over speed times time of collision, the whole thing squared. So if we expand all those terms, then you get what's shown on the next line. And so you'll see that it's a big mess of terms here. So we can do the exact same thing for y and z. Again, it'll look the same. It's just going to refer to a different of the three-dimensions of our vector. So one thing that is interesting to note here is that we were working with vectors, but the fact that we have our u vector, we're taking the magnitude of it. That means any of these vectors we're plugging in, they are going to reduce from the three-dimensions down to a single scalar dimension. And that's going to be because the fact that we're taking the magnitude here, that makes all of you keeping track of the x, y, and z, that all disappears. The same way it would, if we were just plugging directly in three values for u. That means that our delta, which is a vectoring g, those are also going to become just a single value once we're through with everything. All right, so we're now at the point where we've got one equals the fully expanded terms and we've got that denominator, the speed squared times time squared. So we can raise the denominator out because we have a common denominator for the three terms. So you pull that out and then multiply both sides. So now rather than one on the other side of the equal, we've got that denominator: no longer a denominator, but the speed squared times time of collision squared and that's equal to all those terms. Now, we could have stayed in vector form rather than expanding or separating out the x, y, and z, like we've done here. And I'll just go back in the slides. So when we picked that fourth equation, we know that the magnitude of one is equal to u_p x squared plus. We could have just left it as the vector u magnitude equals 1. Let's see how maybe that can make sense with things that we know about vector operations. So you've probably heard of the dot-product, but don't think about dot-product just yet. Let's instead think about, what if we were multiplying two vectors just in general? What would it mean to multiply two vectors? So don't think in terms of any matrix operations, which is certainly matrix operations can help with manipulating vectors. But let's just think vectors as being equations. So we might represent vectors in unit vector form. So we take the basis vectors. The x term of our vector would be times the basis vector for the x-axis, which would be i: with a little hat on it. So i itself is a vector. It's a standard basis and we'd have a one in the x position and then a 0 for the y, and a 0 for the Z. So we've got, say for vector r, we'd have r_0 would be the x term times i plus r__0 times j and r_2 times k. So that's the unit vector representation of the vector r. We can do the same thing with s. So we have the s_0, s_1 and s_2. But paired up with the i, j, and k. So we could just expand I do like a polynomial expansion. So multiplying all combinatorially all the terms. So this is like when you have three terms rather than remember like foil first-outside, inside-last, but in this case we have three terms, so we just have to brute force to go through all of the different pairings as we multiply out. And so you'll end up with some terms like r_0, i times s_0, i. So you'll have a whole set that are match like r and i. Unit vector times an i unit vector with associated coefficients. But there's also some here that are mismatches like i and k or j and k and so on. Evaluating all these terms is like doing an outer product, but the fact that we have an orthonormal basis vectors for our Euclidean space. So that meaning like the i unit vector is 100, the j is 010 and the k is 001. Well, when you would be multiplying those, they're not needed degrees relative to one another, and therefore they just go to 0. So the only terms that are interesting when you're multiplying the unit vector form is only going to be what's called the inner product. If you actually laid out the multiplication of all these terms, which would matrix multiplication, which I believe would be our matrix multiplied by s transpose. So that would give you a matrix with all of these terms in a grid, but only the diagonal would have, potentially have non-zero terms. And so that's the inner product along that diagonal. So we get down to the point where you have r_0, s s_0, and then i times i, r_1, s_1, j times j and r_2, s_2 times k. Now, so far, we've just been thinking of this as multiplication. >> So this is where things get interesting. So if you actually tried to continue this expansion with the i unit vector times i or the j times j or the k times k, the basis vectors are themselves vector. So you could do the exact same thing we just did with this polynomial style expansion. In standard basis, the i unit vector could also be represented in standard basis, which would be 1 times i plus 0 times j plus 0 times k. So you can multiply them, but you could keep always defining what's inside the next level with more basis vectors. So we're at this point where we've got infinite recursion if we just continue to follow that line of reasoning. But clearly, you're going to keep getting the same thing over and over, there's no progress being made. But as you recall, if I go back slides, we were plugging in to the magnitude. So we're replacing the unit vector u, that's referring to the direction of our launch. All of these terms, whether they involve vectors originally or not, because it's a magnitude, it's all collapsing down into just a single scalar value. So we started with 3D vectors, but now the 3D vectors are becoming a single dimension. So in this case, the dot product is a way that we can collapse down, so a dot product is multiplying. But when we get to this point, we can just use the dot product. So in that case we have a terminal condition because we know that the dot product of two unit vectors is always going to be 1. So we replace the i.i and the j.j and the k.k, each of those we can replace with 1. Because we're performing the dot product, we no longer need to isolate our terms separately according to dimension, we're just going to collapse it all into a single dimension. So that means that what we were originally calling r times s is really a dot product r.s because we know that we were collapsing everything down to this single dimension. So that gives us just the dot product of the two vectors. So that's the x term of the left vector times the x term on the right plus the y of the left and the right, multiplied by each other plus the z term, left vector times right vector. And then sum all of those, and that's what a dot-product is. There's lots of other uses for the dot product such as finding angles and performing projections and so on. But we have this notion of how to handle, in an equation for representing a vector like that we just did when we were substituting n for the vector u, we have a way to handle multiplication. Now we can also look at, well, what if it's the same vector times itself? So I did the same thing with the outer product. We know that the mismatched unit vectors are going to cancel out to zero, so we're only left with the inner product. And we could just say that, well, it's just a dot product r.r and we know how to handle it. But we can also notice that the magnitude of r, if we were performing the magnitude operation, that would be, of course, what you're familiar with, the square root of the sum of squares of those three terms. And that looks an awful lot like if we took the dot product of r.r because we're at r_0 squared plus r_1 squared plus r_2 squared. And if we looked at the magnitude well, underneath the square root or the radicand, we've got our sub-zero squared plus r_1 squared and r_2 squared. So it's exactly the same thing. So if we square both sides so that rather than the magnitude is equal to the square root of the sum of squares, we can say the magnitude squared is just equal to what was the same as our dot product. But this is useful for concise substitution purposes in representing our vector. So if we go back to that big mess of terms that we had before where we had performed the substitution in our u vector for the three separate dimensions for the x, y, and z, I'm only again only showing the x. So it'd be three times as long as what's shown here. But if we shuffle our terms around, we will get to the point where we'll recognize, say, for the vector Delta, we've got the square of the x term, the y term, and the z term, squaring each of the terms and then adding them up. If you look where my mouse is here, we can just say the magnitude of Delta squared and then minus; well, when we're considering the fact that we're multiplying the g_x times the Delta x, but we do that for also the y and the z, that's the same as a dot product. And if we'd left it in vector form, to begin with, then we would see that when we perform the square before we did the square root for the magnitude, when actually the square root disappeared, so we just had the square. We know that the g vector times the Delta that you're going to get when you perform the polynomial expansion, well, when you see the need to multiply g times Delta, that's really we just are going to use a dot product. And then also you've got a similar thing where we had a g vector times a g vector for the gravity, and so again, that's going to be the magnitude squared. So all of these different approaches, these are all things that are familiar. Later when we actually need to calculate these in code, we'll just take the magnitude of a vector or we'll take the dot product. So it makes the implementation a lot more concise. And potentially, we can optimize things that you have efficient implementations for these. So we have this more concise representation now, sticking with this vector form and operations performed on the vectors that will collapse down to single terms because of either dot product or magnitude. But we want to set this all equal to zero because we're trying to get to the point where we ultimately want to know u, but we also need to know t. And so t is going to help us to actually solve for u. So that's what we're trying to do now. So we're trying to solve for t. So the time of collision, t_c, currently will see that to the power of 4 and a power of t term is involved. But we're going to move the term that's on the left side of the equal side over, so it's all set equal to 0. We're basically setting up for using quadratic formula. So in fact, that's what we'll do. We have maybe not the familiar form that you're used to in the simplest examples of quadratic formula. So we have the time of collision to the power of 4 rather than to the power of 2. But we don't have any odd-numbered powers in this equation; we have a t_c to the power 4 and a t_c to the power of 2. We can substitute for t_c to the power of 2. So we'll make like an x that is equal to t_c to the power of 2. So that's going to give us an x squared term and an x term. So now suddenly, we've got everything and the form that we can easily pull out coefficients and set up the quadratic formula. So we do that and so that means that it's actually t_c squared is equal to the quadratic formula, plugging in all the correct terms, don't forget about the plus or minus. So we're actually solving for potentially two t's, which we'll get back to that. But then we can now get rid of the square on our t_c by taking the square root of both sides. So we actually have nested square roots. So we have an outer square root and then an inner square root of this entire thing. But what this allows us to do is solve for two possible t's. Even though we're performing operations on all these vectors, we know it all collapses down to a single scalar or one-dimensional value. >> So in terms of implementation and using these t-values to finally solve for u, we look at the inner radicand so, that was the second or the inner of the two square roots. If the value under the square root of the radicand, if that is less than 0 that would suggest an imaginary number. We don't want that, so that would not be a valid solution for either. So if you go back and look, even though there's two possible solutions, if we've got the inner square root, if that equation there is less than 0, then we know the whole thing is an imaginary. So therefore we just say, well, the throw is impossible. And you can see the gravity terms in there and so that would be like the gravity is too strong to allow the projectile to ever reach the static target would be the reasoning there. The other thing is if either candidate time of collision is negative, you will discard each and possibly have none left, if that happened. So if that point, you just return that the throw is impossible. So typically, what you do, is you would set up like a method that returns true or false on whether the throw is possible. If it returns true, there's also some out parameters of the function call of multiple returns, and that would include say our u vector. Probably also the time of collision that was used in the calculation would be useful. So otherwise, if you have two valid solutions, take the smaller one because that's going to be better in terms of gameplay, the quicker projectile to hit is probably the most useful one. You might have some reason otherwise. So for instance, one later in time will tend to have more of an arc to it. So maybe that would be worth considering. So you might revise the implementation if that's needed. Otherwise, if you only have one valid solution, of course, that's the one that you would use. And then in terms of code implementation, you don't want to repeat any expensive computations more than once. So you're going to carefully analyze all of these terms, look for which are terms that have repeated use, and only calculate them once to save user memory, say the variable. So if we go back and look, well, I see the gravity vector.product with our Delta, that appears a couple of times. We've got some squared terms like the speed squared, or you don't want to have unnecessary multiplies anymore than you have to. We've got these magnitudes. That's involve squaring also the magnitude squared. So you're not going to have square root, but you're going to have the square of the xyz terms for the gravity vector and Delta. So you want to avoid those repeats. Also you have the plus and minus. That means that you're calculating t_c0 and t_c1. And they all have the same terms, is just the sign of this plus or minus here is different. So of course, you're going to want to cache across the two attempts to solve for t as well. So once you have your t-value, go back a few slides and you'll recall that we do have the equation for motion of the projectile. So again, that is a function of our velocity or gravitational acceleration, and also the t value. The t, we know it now, assuming a solution was found, we've got a good t to use. We can just plug that in. First, we'll go back to isolating our u vector because that's what we're trying to solve. But so isolate u, then we can plug in our t and all the other information that we know and that will give us the solution for the direction of u. And then as far as launching it in our game, we can just assign our instantaneous velocity change according to the u direction times our speed, so the speed of the projectile. So set this up. And then of course, in terms of simulation, we might have a physics engine that'll just automatically handle applying the acceleration for us, or we would just need to maintain this information. So the projectile will need to maintain the statics and the kinematic. So that would be we need to track position and velocity, and then gravity for our game affecting the projectile. So that would be updated each frame. Now I've got an implementation. I'm going to show you a video here. This is my version of what I just showed you. And by the way, that equation for 3D projectile aimed at a static target with the effects of gravity that is in the Millington Game AI book. So you might want to refer to that as well as this lecture. So here, of course, the target is moving. But it's moving so slowly, it allows me to visualize lots of different positions. So this particular software, the shooting range, this is something that's part of the prison dodgeball assignment. And it's just like a little testbed. So you test out the algorithm that you're implementing for your minions to throw the dodgeball. So this is a good way to test. So having this target moves so slowly, it's a little bit off. You'll actually notice that the green projectiles are hitting on the back edge of the target. But it's still let's me quickly see a debug and also demonstrate here what's happening. Of course, you can tell that an appropriate arc is being applied to the projectile so that it can hit the target. So yeah, this demonstrates that we're solving correctly here. And as long as that projectile's moving slowly enough, we can still get the hits. The physics simulation is being handled by Unity. So they leveraged the X library that is licensed from Nvidia. So Nvidia has developed or they bought the company that developed and they continue to refine that physics engine, but it's just doing some simple Newtonian style physics updating. Now the projectile is not under the effects of gravity, it's just moving along a random trajectory, but it's constant velocity. So it just goes back and forth, bouncing against like an invisible wall. Now here is the same algorithm aiming under the assumption that the target is static. Now it's moving at full speed, and you can see that it's not very successful. It's always aiming to a position that's well in the past by the time the projectile gets there. So, yeah, that's a problem. But we can potentially still make use of this a good course if truly the target is not moving, it's useful. We'll also see later how we could use an iterative algorithm. So we've got this approach in terms of prose it solves directly for a 3D target position with gravity affecting projectile, so that's a big step up from what we've seen before. And downside, of course, is it doesn't handle moving targets. But otherwise, this is definitely a useful ability for aiming that we'll see with incremental. When we add this incremental refinement, we will build a handle moving targets.
