>> Hello. In this video, we're going to cover the topic of computational geometry. So computational geometry is basically just a study of algorithms that pertain to geometry. In some cases, it might involve framing a problem in geometric terms or directly working with geometry, which is our case. Using algorithms for understanding geometry or interacting with geometry for the purpose of supporting our artificial intelligence, especially related to path planning. Converting the game world into a data structure that can work for path planning, for instance, is probably one of the main scenarios that we'll be interested in computational geometry. So the motivation is for robustness and provable correctness. That is something that we will value or application to AI is that we do desire a robust solution. We don't want to have any bugs introduced in our AI behavior because there's some flaw in our geometric processing. Again, this is applicable to converting the game world, this is a process called discretization, which we will talk about further in other lecture videos. But it'll address things like whether a polygon or a region contains a test point. A point containment might be checking for whether two line segments intersect or a line intersects with a polygon, or two polygons intersect. These are the geometric tests that will be valuable to us in some of the work we do, especially related to, again, discretization. Also, triangulation is another important topic, such as taking a complicated polygon and breaking it down into more manageable triangle shapes. So first of all, I want to bring attention to something that is problematic and that is floating-point representation of values. So we know that in a game world, we often have 2D or 3D vectors, and those are floating-point values. Each of the scalars in say, a position vector for instance, and those vectors could define a geometric regionally. We can take three points from the world and then we would have a triangle and we could use that to perform different sources of geometric tests or manipulations. So let's look at the float and see if there are any concerns related to that. So first of all, floats are represented with bits. They don't have arbitrary resolution. There's a fixed number of bits, so your typical float is going to be 32-bits on most systems. And there is multiple IEEE standards for floats and there could be other standards as well, but the IEEE standards are the most common. And what you'll tend to see is you'll have a sign bit, some number of exponent bits, and then fraction bits. And because of these fixed allocations for each of the parts of the floating-point, this introduces the possibility that if we're starting with a decimal number and we want to represent it as a float we will often not find an exact measurement, so we're going to have some rounding error where we're not going to be able to precisely hit our target number. And also going from one number to the next, like the next adjacent number in the sequence that is possible with the float. That smallest difference between one float and the next or the float that goes prior is going to vary, especially related to the exponent. So as the exponent gets bigger, but we only have this fixed number of fraction bits, that means that we might not be able to represent a very small difference of a number would say a larger exponent. Because as exponent gets larger and larger that representable difference increases. So these are issues that affect us. I've got a little recording here. This is from a website float.exposed, and of course, you can check out the lecture notes for the link. Check it out yourself. I've just got a little screencap. This allows you to play around with float number representation. So you can actually see what the bits are, what the value in decimal form is that matches with that. It might be small in this video to actually read all the labels for the fields, but maybe if you can get a full screen, you'll see the bottom number value is delta to next or previous representable values, so that's what I'm referring to you about that difference. If you have particularly large numbers that will become bigger and bigger and so that has implications on calculations. >> And just the fact that it varies makes it difficult to work with floats when you want to have any guarantee about a value. In practice, how might you use floats in geometric calculation? So let's consider a scenario. Maybe we have three points and we want to test if they're collinear, meaning that they're all three points on the same line. Of course, any two points forms a line always unless they're exactly the same point. But in the case of three points, they may or may not be collinear. So we might define a test that can make this determination. Maybe we look at the angle formed by two different edges. So we have three points, maybe A, B, and C, we could perform a dot product of BA and BC and then from that, based on the size of the angle, make a determination. So we'd want to see if that angle was at a particular value. Or maybe we would take the area of the candidate triangle formed by the vertices ABC and look to see if it has an area or not. So that could be a way to make a determination. Now if you are trying to test for some particular value like zero with a float. Well, chances are because of the problems we saw with the floats earlier, the rounding error and the minimum difference between two floats, you're probably not going to be able to achieve that. So in cases where you would want to have logic like if v equals target, instead we'll add a fudge factor and this is where our Epsilon value comes from. And in this case, we would need to do something more like the second if statement on the slide here. If v is less than target plus Epsilon, and v is greater than target minus Epsilon. And that Epsilon might be divided by two, but we probably have that pre-computed if we were to do that. So that Epsilon range means that there's an area around the target value that we will accept as being close enough. And that strategy is used to deal with the fact that our floats do have this rounding error problem and the resolution problem. And so typically if you use this strategy, you will perform the calculation that you're familiar with in geometry and using floating point values. And then you will make a test like this, pick an Epsilon value, and then you maybe play around with the Epsilon until it passes the handful of tests that you throw at it and think, okay, well, it looks like it's working. But I can tell you from experience that you can run into problems with this. For instance, let's say you are writing a test to see if two line segments intersect. And so there's a variety of approaches that you can take to achieve this at least to some level of success. So maybe you get that working and you give a few ideal cases where the edges are clearly intersecting and do handful of tests and you sign off on it as, okay, this works now. Then you build up more complicated geometry based logic. So maybe your objective and building the line segment intersection test. So, excuse me, you really wanted to test if one line segment intersects with one of many line segments of a polygon for basically a polygon intersection test against a line segment. Maybe initially this does work well for you. You throw a few different tests at it and then it hit any of the edges of the polygon, get a collision with your team the rest of your application on the assumption that this works perfectly. But then as you get into more complicated examples, where the tests that are being generated are part of the overall application, then you start to realize that you're running into some problems and if you investigate and debug long enough, maybe you track it down and you figure out exactly how your geometry tests are failing. So for instance, a common one would be that you have a line segment that perfectly aligns with two vertices of the polygon. And so those are special cases of the edge test or edge intersection test. So if your two line segments intersect in such a way that just one is touching the edge but not a full intersection. Then this can be problematic. The type of problems you can run into with floating point and the variations that might occur can lead to these problems. So the alternative to floating point is to first convert our floating point values from the game world or the level. Convert relevant geometry to an integer based representation. And so this is really a straightforward process. You can just take each float and multiply it by some number and then cast it to an integer. So the reason why you want to multiply it by a number is because you're often needing that fractional part of the float just based on the common sizes and differences. That maybe isn't always the case. Maybe you could just drop the fractional part around depending on what your values are. But in a typical case where you have an origin at zero and you have relevant game world geometry in the neighborhood of the origin, then you're probably also going to have a scale such that the fractions are important. So it's common to, if you're going to do this mapping, you'd be like maybe multiplying by 1,000 and then casting the number to an integer or rounding it. And so at that point, all the values that were floats are now these integer vectors of much larger values than before, but can easily be used for geometric calculations. And as we perform these, perhaps generating new derive geometry of some sort, then we can convert that back again to flows just by going in the opposite direction with the calculation. >> Deciding when to convert is something you need to pay attention to because there is a lot of overhead with performing this conversion to an integer being applied to all of say, your polygons. Let's say you're building a nav mesh for instance, that's something we'll talk about in a future lecture. That is going to have some overhead. You're going to be substantially increasing your memory usage because you're going to be duplicating all your floating-point vertices with integers in vectors. So this is something that depending on why you need the computational geometry robustness of working with integers, most likely it's probably that you're generating something that some new data structure that you want to be able to work with. And so it makes sense to do this at the part of building the game before you'll be playing it. So whatever your build process is, we consider a baking process. So maybe after you've compiled your game, you would then run some tools that prepare data before you deploy the game to a playable version. And so you have a baking process. And so you can see examples of this. If you're familiar with the Unity game engine, there are a number of things that you can bake that involve computationally expensive things that can be cached and that data preserved until the point in which the game is run. And so this includes their nav mesh implementation, which has a baking process, also things like calculating lighting. So you can have precomputed lighting effects. And there's a number of other things that involve this framework of baking and then caching expensive computation to use in the game. So once we've converted to integers this can allow for much more robust calculations because we don't have that varying difference in the float. What's the minimum difference in float values and also the rounding issues. Those are largely addressed with the integer. So we can still perform the same calculations. It's just they're much more repeatable within a range of bounded integer values. But one thing do you have to watch out for is overflow. And so when we have this fixed-point representation of numbers, you have to be careful in certain types of calculations. Maybe when you have a series of multiplications or sums, you can end up overflowing the integer. And this is especially problematic because many languages do not through an exception on an overflow C and Java, I believe C#. Many of them, I think it's either difficult or system-specific. Even if it's possible to generate an error. And even if it could generate an error, it would probably have a huge impact on performance. So in the case of computational geometry, like implementations on computers, generally use some other strategies instead of just trying to have an overflow error generated. Instead, you look for opportunities to reorder equation terms. So any computation you are performing that equation. Sometimes you can restructure it, pull multiplications out, or manage a numerator and denominator separately until a certain point. And so that can help to avoid a scenario with overflow. You also might be able to enforce some bounds on the minimum and maximum integer values that you will be processing. So really robust provable code. You could consider the chain of calculations worst-case. So if you were taking the biggest or the smallest number all the way through the chain, then where do you set those limits such that it would be impossible to achieve an overflow, so that's certainly a possibility. And then you can also even use more bits if your system supports it. So for instance, like your typical C-style int would be 32-bit integer, but you could potentially have 64-bit integers. In some cases, it might even make sense to use. If you're working on a system that doesn't have 64-bit integers, you might could use a double, which is going to have much better resolution than a 32-bit integer. And so as long as you stay within a certain bounds, then the fractional part, like a fixed exponent, would have pretty good range. So in summary, achieving any robust computational geometry is very challenging, not only because of the issues like special cases in geometry, things that you need to consider like edge cases or degenerate geometry. And you have to consider all the different possible scenarios and checking for different conditions that might be possible. You also have to consider the implications of implementation on a computer, especially the floating point problem that we've just discussed. So anytime that you do need to come up with a solution involving geometry is definitely worth doing a survey of the literature to see if someone's already addressed your problem. Maybe there's a well-established algorithm. Or at least bring attention to different edge cases and possibilities that may be you had not considered. Then when you are implementing on a computer, it's a good strategy to just go ahead and assume that probably an integer-based solution is going to be the most robust, and then aim to do that whenever it makes sense to do so. It's often good to avoid solutions that involve analyzing or calculating and comparing angles. Often you can find other solutions that are more robust like calculating areas, for instance. And then, of course, also testing's important, especially if you're going to be building some basic geometric test and you're going to build up from that to more and more complicated computation. It's tempting to implement something with minimal testing and say, oh, this is pretty good, and then just immediately move on to the next more complicated thing. And you can end up building a house of cards, not realizing there's some fundamental flaw in the core functionality that the base level, say, an intersection test, if that's not doing exactly what you need. And then as you try to build up around it, you can end up wasting a lot of effort getting to something that's, say, 99% effective but then fails 1% of the time. And you have no control over that 1%, just, say, the nature of your application or your game. And so you just end up wasting efforts. So in conclusion, if you're doing anything that involves geometry, you need to consider how important it is to be robust. And if that is extremely important, then it is going to take a lot of effort to get that to work. So we will revisit the topic of computational geometry more, especially in the beginning first handful of lectures in the class as we are considering path planning and representing game world space through this discretization process. So we will stop there and again, look out for this topic to come up again.
