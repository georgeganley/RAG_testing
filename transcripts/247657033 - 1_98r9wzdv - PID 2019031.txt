>> Hello. In this video, we're going to continue looking at procedural content generation. In particular, we're going to take a look at grammars used to generate our procedural content. So we've previously seen rule based procedural content generation, such as the rules that we use to shape and sculpt our Perlin noise and this was very powerful at least for that purpose. However, that approach is insufficient for making guarantees about certain game play features that we might desire. For instance, navigable connectivity meaning creating an environment such that our game player can traverse from one location to another. We might be able to make some rules that tend to favor navigability. But it's very difficult to make any logical guarantees about the nature of our environment, we have this very emergent outcome. It's difficult to predict exactly what's going to happen. You just have to play around with it, try it and see if you get the results you want. So what might we do if we want to have more direct control over the content we generate, at least in terms of some guarantee? This is where we can use grammars. The technique of using grammars can be seen in games such as Spelunky that connects several different template rooms together to create small dungeon-like environments in 2D that the player can explore and face randomized challenges. But it's all done in such a way that there are guarantees about connectivity. But furthermore, that the character that the player controls can actually navigate everywhere that they need to. In terms of climbing and jumping, and moving around, if you're not careful with other techniques, you might generate something that say is aesthetically pleasing. But you can't actually make the jumps or you don't have ladders and other means of navigation available to you. So this approach of generative grammars, it originates from Noam Chomsky's study of languages way back in the 1960s. And he came up with this concept of components or symbols that are interpreted with rules. This defines how the combinations of symbols can be put together, and you can apply it to lots of different problems, language in particular, words can be placed together in sentence structure according to grammar rules. You might also apply this to content generation in a video game. For instance, you might have a generative grammar that builds body shapes for aliens. So the rules would be specified by a designer and it would allow for generating different types of creatures. In Spelunky, each level starts out as a grid, and then each grid cell gets filled with potential templates. These are all pre-designed by the game designer Derek Yu. The templates get filled one by one and then later templates are chosen according to rules about how the templates can neighbor one another. So I've got a few more details from a YouTube video that I will play a little bit of. I recommend that you check out the full video on YouTube. I'll have the link in the notes. Let's see. Let me get this started. I'm going to jump to a particular spot here. >> So every level in Spelunky is generated by a script that starts with the same basic shape and size, 16 rooms in a boxy four by four grid. The first thing the script does is pick a random room from the top row and makes this the entrance. It will then randomly place a room to the left, right, or beneath this room. This process is repeated from room to room, and if the path hits the edge of the level, it also goes down until we get to the lowest level. When it tries to go down once more, an exit is made. Every room on this main path has openings to the left and right, but rooms where the path drops also have exits on the bottom while the rooms you drop into, are given exits at the top. What do you end up with is a guaranteed path through the level that you'll always be able to get through without using ropes or bombs. The other rooms are not on the critical path, so they may be open or they may be walled off depending on their design. Next, each room is randomly given a template. Derek Yu handcrafted a number of room designs with different layouts for rooms where you drop down, rooms you land in, corridors you run through, and rooms not on the critical path. But these templates are not set in stone and parts of them are randomly generated. Sometimes, entire chunks of tiles are plastered on at random. This means that while you might start to see familiar setups, they will always have their own unique quirks. Next, a script checks every tile on the map and rolls a dice to see if it should place down a monster, some treasure, or another object. Again, it's not entirely random. Gems and crates are more likely to appear in spaces surrounded by walls and enemies generally don't spawn in cramped spaces, and everything is weighted, so a level isn't filled with fire frogs or crypts containing jet packs. [MUSIC] >> So that was a little look at how Spelunky works. So that is from the YouTube channel I believe, the Game Maker's Toolkit. So I recommend that you check out the complete video for some more details about how Spelunky levels are generated and also the impact on gameplay. So the nature of the gameplay, the fact that it's not something that the player can memorize, it means there's an entirely different strategy to becoming proficient at the gameplay. So it demonstrates a type of gameplay that's really only possible with procedural content generation and that's a large part of the appeal of Spelunky. Next step we're going to look at a different type of grammar called an L-system or Lindenmayer system. So this is a type of grammar where each piece of content changes every timestep. So you have a starting point and then you keep replacing a symbol according to some rules. So you will have variables, constants, and then rules that you apply. And then there's also an axiom, which is the starting point. And so you can select between all of these to come up with different ways to generate your grammar. And then you also additionally need something that interprets the end result, which is basically reading the sequence of symbols that are generated and following the instructions that are implied by the symbols. So we might have an example of building a tree-like structure. So we could have variables zero and one, and this represent some structure and we have constants such as brackets or parentheses. And so this cause a behavior like a rotation, and then we'll have our starting point. So from that starting point, we have the symbol zero, and then there are rules. So there's one rule that shows the mapping of the symbol one to a new configuration. And then there is another rule for zero and mapping it to a new configuration. And so the zero could be replaced with a one and then a zero inside of braces and then another zero. So you can keep applying this until you get to some terminating condition, and then the end result can be interpreted by a rendering algorithm that understands the deterministic messages that are part of the grammar. Here is another one. This is from Wikipedia's page on L-systems. And so this particular example has variables X and F, and constants plus, minus, and brackets. So the axiom or starting point is the symbol X, and then there are rules for how the L-system generates. So the F means is interpreted by the algorithm that draws the plant. So it draws forward, and then minus means turn left 25 degrees, plus means turn right 25 degrees. And X is not something associated with the drawing action. It's just like a placeholder and so it's used for facilitating the rules. And then the square bracket acts like you might expect parentheses to work. So you're saving state so you can remember what the state was as you go down to the sub-branches that you're drawing, and then so you can go back to where you were before in terms of a position. And so this can drive through a very simple set of rules, can drive some pretty complicated and natural looking fractal plant type structures and you can use it for lots of other things as well. Grammars are nice that they have good general usage possibilities, lots of different types of content can be created using different types of generative grammars. You can get very high quality often, have this natural look to them, especially things like trees. It's very accessible, it's easy to work with. You don't necessarily need to be a programmer or computer scientist to work with this so you can have authoring tools where the ability to write grammars is something that lots of people could quickly pick up. And they also tend to be very fast, just the nature of the symbol processing. Downside though, puts a lot of burden on the designers. A lot of time will be spent configuring and tweaking to get just the right results. It's got this emergent outcome that can be hard to debug once you start to add some complexity to them. And it's really just observing the outcome of using them. It's not a true validation that the problem is fixed. You might have just moved from having a problem in one area to now a new area, whatever change you applied. So any change to the rules affects all possible outcomes and there might still be some edge cases that could be a problem in the future. So grammars, especially L-systems are commonly used in things like trees and other types of plants. You might also use them for things like avatar generation to the different body features, or aliens, different types of anime. So games like [inaudible 00:15:27] have the different creatures perhaps you have a generative grammar for that. Some types of level generation are well suited to grammars. It seems like 2D games especially can work well, and I'm sure you can come up with several other examples that would work well. So grammars are a pretty important aspect of procedural content generation. You'll often see it coupled with other approaches. So perhaps it would be a component of terrain generation for generating the different types of plants that you want to place in your procedurally generated world.
