>> Next step we are going to look at how to solve for a ballistic projectile intercept with a moving target. So previously we had a static target. But now we're going to change the problem such that we have a moving target. So we saw with the static target solution, it worked well for that purpose but in order to handle a moving target well, we could continue to work with that algorithm and then implement an iterative solution around the static target solution but first, let us consider actually directly solving for a moving target and if that is reasonably possible. So we're going to have to simplify the problem in order to get this to work. We're going to have to go to 2D and if we are to apply this to say a 3D scenario, we're going to have to project it all down onto the XZ plane and we will have 2D vectors for positions and velocities of the projectile launched position and the targets initial position and the velocities. So also, we're going to say that the target and the projectile are going to move with constant velocity. Our projectile is not going to be affected by gravity. Of course, this is in 2D and it's in the XZ plane so we're basically ignoring gravity. And for the projectile, we only know the speed and where we're calculating for launching at full speed. So we'll later see that even though we're restricting this to 2D, we will be able to come up with useful solutions to the ballistic trajectory for 3D as well. But there will be some caveats, so we'll wait and see about that. So some variables, we have initial positions for both the target and the projectile and that's because both of them are moving. This is only going to be true for the very first part of the motion and the ultimate intercept. We also have unknown velocity for the target, there's a constant velocity so no acceleration. Of course there's the target speed as well, which would be the magnitude of the targets velocity. We have projectile speed so this is how hard you're launching your projectile, the speed of the launch. We don't actually know the direction. So we're going to be solving for the projectile velocity. And then we have the time of the collision. So this is the time of intercept that we'll be trying to solve for in addition to solving for the velocity of the projectile. So we're going to rely on the law of cosines. So you might recall this from taking a trigonometry class. And so the law of cosine says that for a triangle with sides a, b, and c, where the angle between side a and b is Theta a squared plus b squared minus 2ab times cosine of Theta is equal to c squared. So we're going to use that and also we're going to rely on the dot product as related to the angle between the two vectors you're taking the dot product of so vector a.b is equal to the magnitude of a times magnitude of b times cosine of Theta. And it's also useful to know that if vector a happens to be a unit vector and also b happens to be a unit vector, a.b is just cosine of Theta. So we're going to leverage both the law of cosines and dot product rule for angles as well. So in order to apply the law of cosines, we need to assign equations to the edges of our triangle. So for edge a here that the way that we've set up our mappings for the initial position, so we've got the initial position for the projectile is on the left side, so the corner ca of the triangle and then we put the initial position at the target at corner ab. And therefore, the length of edge a is going to be, well, we take the relative position vector between the initial position of the projectile and the target so p initial target position minus p initial projectile position. So it's a relative position vector we can take the magnitude of that and then that gives us a length or to assign to the triangle so that we can eventually plug this into the law of cosines equation. We also know that the speed of the target is equal to the magnitude of its velocity. And we can set up our dot product relationship to angles as the dot product of normalized form of a, which is a unit vector. So take that a which again, is the relative position vector,. P initial position of target minus p initial position of projectile. Take that vector, normalize it to a unit vector so that is a unit vector dot product, the normalized velocity of the target and so that is also a unit vector with a two unit vectors dot product, we know that's equal to the cosine of the Theta. So now we know the cosine Theta part of the law of cosines equation. So we're starting to fill out this triangle here. So next step, we'll use some particle dynamics, the displacement by velocity so if you take a vector v times some amount t, then you know how much it moves in the x and the y dimensions. And we could also just figure out, well the magnitude of this movement. So we can take the magnitude of vector v times t and determine the length of the vector rather than the movement in individual dimensions. So magnitude of velocity is going to be speed. So in this case, the speed of the target times the time till collision. So how long has it taken up to the point of collision? So that's what our b is and we don't know the t time of collision yet. But we do know the speed of the target. We know that b is equal to this. So we're setting up a system of equations basically it's going to let us solve for this t that we don't know yet. Similarly with c, we know the speed of the projectile times the time it takes till collision, that's going to be that length. So now we've got the whole triangle, all the terms needed we have now determined. So we plug in our a, b and c into law of cosines. We get our a squared plus speed of target times t square that minus two times the length of the edge a times the speed of the target times rt and then or recall, the cosine Theta so we can replace that with the dot product of normalized vector a times normalized vector b. And all of that is equal to speed of the projectile times t that squared. So we can simplify all this and we work our way down to the last line here and we see that we've gotten everything into a form where we've got a t squared and a t and we're now at the point we can plug into the quadratic formula. >> So we do that. And it is a similar scenario to what we had in the previous solution for the static target and 3D with gravity. Little simpler because we don't have the nested square roots, but we still have the same concerns that we want to test the radicand value, make sure it's not negative, which would give the imaginary. Now, we also need to check the denominator here, because it's possible for it to be zero. And we have again the plus or minus, so that means two possible t values. If we do have two valid ones, we're going to use the smaller of the two, that means it's a quicker intercept. And you always want to favor the quicker intercept, because we're making this assumption that, say, the moving target is moving at constant velocity. But in reality, if this is a game object controlled by a human player or another agent that we're trying to hit, there's no guarantee that it's going to maintain this constant velocity. It's a good heuristic, but it's a heuristic that rapidly becomes less and less likely to be true over time. So I want to keep that t small. And then another thing to look out for when you're actually implementing this encode, look for repeated calculations. There's some common terms like the normalizing of the a and the b vector and then taking the dot product. Do you want to cash as values? You see that it shows up twice in the equation. You have the relative position vector calculation. So you've got just several terms here that you're only wanting to calculate once, because there's multiplication involved and those add up over many agents, many frames. If you're doing this over and over, you want to always look to right efficient code. You also have the plus and the minus, so don't forget that you're going to repeat terms that way as well. So cash that square root and use it again when you doing the plus or the minus version. So you do all that and, well, you've got a t-value. We still don't know the velocity, and that's the important thing, because that's what we need to build a pass to our simulation to actually launch the projectile. So we're going to set up a name to new vectors here. The position of the target at collision and the position of the projectile at collision. It should be obvious that those are going to both be the same position, but the way we get there is coming from different directions. Here we have the motion of the projectile, the motion of the target. But we know that at that one point, they're going to be the same. So the position of the target at collision is going to be equal to its initial position plus its velocity times time, which for a constant velocity object, that is what you would expect from the particle dynamics. Now, we also know the velocity of the projectile, well, we know the initial point and we know the end point. We don't know the actual velocity, of course. So we know the relative position vector between the initial point and the final point. So we can divide that by t of the time of the collision. But that's not useful until we replace the final position of the particle in the equation. So that's shown in orange. So the replacement we're using the position of the target at the collision. So you see where I'm mousing over? So we're just plugging that in for the final position of the projectile into the equation here. And then we can do that because we know this just by this scenario. We know that those two positions are the same, because of the fact that they're colliding. So this substitution is valid, we can now simplify. So we got the denominator cancelling out for that term, for the v; velocity term. So we don't have a dividing by t here, but then we do have this relative position vector. So the initial position of the target minus the initial position of the projectile divided by t and then plus the velocity of the target. So that is our final solution, that's in 2D. Now, this equation that we have, so even though we're solving it in 2D, we probably got here by projecting the XYZ. Assuming we're using this solution for a 3D game, we can just project everything down to XZ plane and then work with 2D. But this final equation, we could actually treat it as 3D. There's nothing that would stop us from doing that. So we can plug it in. Now, here's the thing. That'll work, it's functional. You'll have a projectile that will actually go and hit. But we've totally ignored any impact of the y direction, on distances and so on. So basically the situation you have is, we ignored the y, but then we suddenly added in. So it's very likely, the magnitude of this velocity of the projectile, the initial velocity of the projectile we solved, it's going to be bigger than this maximum speed that we initially defined in the problem, that's quite likely. Now this may or may not be acceptable in terms of your gameplay. Some games that'll be fine, it looks natural as something's farther away and up at an angle, the agent just throws harder because it's maybe more effort. Sometimes that's not acceptable and you might want to actually impose the speed limit. Now another thing, we could even not only go to 3D, but we could have 3D with gravity. And so to make that adjustment, when we're solving for velocity, we have to do it differently because we have a new equation for motion for the projectile. We know from particle dynamics with the influence of gravity, you would have the new position would be the initial position plus initial velocity times time plus 1/2 acceleration times time squared. In this case, we're going to have a gravity vector and it's going to include a sign probably like in the Y dimension. You're going to have negative 9.8 meters per second squared. So we would have the position of the projectile at collision is equal to the initial position of the projectile plus velocity of projectile times time of collision plus 1/2, the acceleration due to gravity, times the time of collision squared. So now what we can do, is we can set that equal to the equation for motion of our target. So we take that, the right-hand side of that equation. We're going to substitute the final position of the projectile, substitute in where is the target going to be after the amount of time elapsed for the collision that we've already solved for? So that'll be the initial position of the target plus the velocity of the target times the time it takes for the collision. So now we've got to shuffle terms around, just some basic algebra. We can isolate the velocity of the projectile, so we get this new form. So you can either use this form if you're not lobbing the projectile; it works for 2D or 3D. Again, with the caveat about 3D possibly throwing too hard. Or you can use this v_p if you want the projectile to be lobbed, and it'll be a correct velocity, taking into account the gravity and it still hits the target. But again, we still have this problem probably to a larger degree now that the magnitude of the velocity of the projectile that we just solved for is quite likely to be greater than the maximum speed that we had assumed at the beginning of setting up this problem. Again, that may or may not be an issue for your gameplay. So like I said before, when you have an agent like, say, throwing a football or something, it looks like they're just throwing harder, within reason. If you don't impose any limit, it can get ridiculous. I'll show you an example in a second. But it does tend to not look too bad in most cases. But you might have gameplay where it's really important to impose the maximum speed. >> Next step I'm going to show you this in action. We've got a target that's moving at various speeds. We don't need to slow it down super slow to get our hits. And you can see that we are getting hits in 3D with gravity. This is cheating. This is throwing harder when it needs to. Right now since it's throwing down, that's not as bigger deal. And this little shooting range, it just randomly moves. So actually, I don't think I really have a good example in the video of throwing up, but there is at least a difference in height that's taking place. And you probably, if you paid close enough attention, you'll notice that the speed changes depending on the relative positions there. So in this next video, I demonstrate this cheap problem that is occurring. So I modified here. Actually, it takes a little while to play out. So I think I have initially got the static collision solved. So I'm right on the edge, you can see, manually moving the target. I found the edge of a 45-degree trajectory with a static solution, so the previous video solution there. And then I changed the algorithms, I switched over to law of cosines using the cheap method. So it just solves whatever it needs to solve. And you see I'm dragging it further and further out. I'm well past the point that the static targeting was maxed out. It was returning false. It couldn't go any further. I'm having to zoom out because there's literally no limit here other than the size of the arena. And so it just adds arbitrarily much energy to the y. Sorry, it's small in this video, but hopefully, you can tell that I've moved well past where the limits should be the projectile's being send in an incredibly high limit. But you could separately screen. You could just have a distance cap perhaps like beyond a certain distance, even if the algorithm thinks it can come up with a solution, you just say that the overall distance between where the launch is and the projectile ends up, that it just went too far and so you can just say, well, that was not allowed. So in terms of this solution using the law of cosines approach, it does solve directly for a moving target in 2D. And if you're to have a 2D game, it's great for that. You could still make it work for 3D as we've seen. It does not impose a maximum speed in 3D though. And also if you're using this for 3D game solutions, it's not ideal for extreme height differences or targets that are moving significantly in the y direction. If you had a flight sim or a space combat game, it's not going to be ideal for that. You could make it work by choosing the best plane in 3D to project onto, not always projecting onto x, z. You might project onto say, x, y, or z, y or whatever, depending on where the game objects are and what the game object that's launching the projectile relative to the game object that is the target and what's the closest plane that they're both moving in. So you'll probably come up with a little metric for that, but I honestly would just use the prior solution with an iterative approach that we'll talk about in another video. One other thing I wanted to mention is that there's a trick you can do with the law of cosines. If you do want to impose a speed limit, you can use this holdback trick. And the holdback is basically, so you know what your maximum speed limit is. So when you call your algorithm or your law of cosines implementation, you pass it a speed that is 90% of what you actually want to allow for. So that leaves a fraction of the total speed that can be applied in the y-direction. So any loft that you might need on your solution. So if it successfully finds a solution for the lob projectile in 3D, again, the velocity is going to likely be higher than the limit you passed in, but it might not be higher than the holdback percentage. So if the launch point for the projectile and the position and movement of the target are roughly in the same plane, so there's not a big difference in height, this will work fairly well. So if you have an enemy that's running on a flat surface and you have an agent throwing also on that same flat surface, this will tend to work fairly well. If there's extreme differences in height like one agent up on a hill or right near the maximum limit, so close to where the furthest your agent is going to be able to throw, not taking into account a hill, they're not throwing downhill or something, it's going to be a 45-degree launch angle. I'm sure you've worked these problems out before in your particle dynamics physics class before, but 45-degree angle is the optimal for distance. Clearly, if you're only holding back 10%, that's not going to allow for a 45-degree angle, but if you hold back too much, the problem is what you end up with is you reserve too much energy for y, but the algorithm is only going to use as much y as it needs, that little adjustment we made for the lob particle. So you end up with solutions throwing not as hard as it could be. If you're trying to throw a projectile to do damage like a weapon, if you're throwing soft, your agent is going to be throwing soft. And that's not really what you want. You want to throw hard because you want to do more damage, make it more likely that you're going to hit your target. So this is okay, but it's not the greatest solution. But again, that's only if you want to do like lobbed in 3D and truly want to enforce the speed limit. So we can look at the holdback version of law of cosines here. And so one thing you'll notice is if you look at the shots per second here, this has been running for a while. So this has already gone through 2,000 and something hits. And the shots per second is averaging around [NOISE] 250, and that's pretty low compared to, well, if we went back and looked at the cheating version. That's the highest we'll see because it was cheating, but if we wanted to compare it to other approaches, that speed limit, you'll have to look at the next video where we're going to use iterative approaches, but you'll see that this isn't competitive with the other approaches, but also this scenario that we're seeing is probably not where you would want to use the hold back version of law of cosines anyway. You would rather have the movement of the target and the place that you're shooting from all be roughly in the same plane. In that case, it works a lot better. So like the assignment for the prison dodgeball where you have the little minions throwing the ball, [NOISE] that's a lot more realistic for using this. And I would even in that case recommend an iterative solution just to find as many possible solutions for when it's good to throw the dodgeball. But this is just interesting to consider because it is simple to implement. It's not as difficult as adding the extra iterative part.
