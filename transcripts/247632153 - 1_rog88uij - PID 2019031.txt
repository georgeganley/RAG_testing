>> Hello. In this lecture, we're going to take a very brief look at rule-based systems. So just an introduction to the basic concept and set the stage for comparison with say, decision trees and finite state machines, behavior trees. We will revisit rule-based systems in the future and look at some more advanced implementations. But for now we're just going to focus on the basics. So rule-based systems, it was a very popular strategy for early research in AI, so especially the era of symbolic AI and expert systems. Rule-based systems were core to that effort. So that was the height of research in the '70s and into the '80s. A lot of the original implementations were in Lisp, which is a language dedicated to manipulating list data structures. It's not necessarily appropriate for video games though there have been games in the past that have either been built with Lisp or had a AI subsystem that worked with Lisp. So in terms of what a rule-based system is at its core is not a whole lot more than just a series of condition action statements, so like if condition then perform action. So it's similar to decision trees in that it's a really simple concept. But we can build upon that to pretty complicated systems. So the simplest way you can probably set up a rule-based system is production rules where you just have a fixed priority, arbiter. So we haven't defined what that is. But it basically is the notion of dealing with the possibility that you have lots of rules that could be executed, and so that would be called, the rule is activated. So if you have lots of rules that are activated, how would you pick one? Well, we're just going to skip over that whole scenario by setting up our rule-based system in such a way that we don't even have that come up. So in this simple strategy where we have this fixed priority arbiter, we are just going to have a series of if statements basically. And we are going to analyze each one in order and then determine if it activates, meaning if the conditional statement evaluates to true, then we'll have an action that's matched with it. So that's like the if after the then statements. So we have the if condition then action, that action, we're just going to immediately return that to execute. So we're not going to further consider any rule. So we have this implicit structure for execution, so it will take a look at that in a second. So as you can imagine, this is very simple architecture, even if we add a little bit of complexity, rule-based systems at least in terms of representing the condition and action statements that itself is pretty simple. And sometimes the interpretation like in more advanced rule-based systems that can get complicated. It can however be difficult to organize if you have all of these statements in isolation, there's no structure, there's no grouping or organization. Typically, so if you just looked at all of the rules that might be part of a rule-based system, it's not necessarily going to be easy to interpret or to organize or to figure out like, if you are given an existing rule-based system, how do you extend it so that it effectively adds new behavior to an agent or improves upon its decision-making? That is a challenge. So here is an example of production rules with just the simple implementation with fixed priority. The priority is defined strictly by the order in which the statements are presented. So the first statement is executed and then you move further from there. Now typically, the way these work, when you have this fixed priority, you'll need to place more specific scenarios first and more general scenarios later. So for instance, you might have logic for an agent dealing with encountering an enemy. So you could say if the big enemy is in sight runaway, so that's a specific interpretation of the enemy that is available through the state of the game. We can make a query against the game state. And maybe we have a method that we call that we can calculate whether it meets our insight and also the size of the intermediate, like some decision-making process there. So that's a specific analysis of the state of the world, and of course, if that matches immediately, we can return the action runaway. And so that would be then executed by the game, maybe steering behavior perhaps. And now the second statement, so if that first statement does not evaluate true, it's not going to execute the action. So now we're on the second statement, if enemy in sight fire, so in this case it's more general. So imagine if we swapped those statements, the first one now being if enemy insight fire, that would mean that if there ever was a big enemy in sight that logic could never be run. So that's why you have to think in terms of more specific to more general. >> So let's see. In fact, we actually can have multiple rules that could evaluate to true. So normally this is a big problem in a rule-based system. And that being typically more general purpose, more capable rule-based system implementation, you would evaluate all of your rules and figure out which ones are activated and then from there you'd need an arbiter that would select as appropriate. But again, we have simplified the problem by just saying we have a fixed priority, the priority is defined by the order in which we list the if statements, and that is an implicit arbitration, so we don't need any special logic to evaluate. If you've ever set up firewall rules for networking, so the firewall settings to decide which packets or connections to allow on different ports, you have the same logic where you have to put the more specific scenarios first in the list and then progressively more general as you go. So this can work really well for simple agent AI decision-making, and it's nice in that it's stateless, so of course, like a finite state machine where it's got state in the name. So we don't have any overhead of maintaining any state, so no impact on memory. Evaluation is also nice because, and this is rare for most rule-based system implementations in that the worst-case would be evaluating the very last rule, each rule in a sequence would evaluate false until the last one evaluates to true and then we'd run that. So in worst-case, it's going to be ON where N is your number of rules, but on average, you might partway through the list. And so if you don't have any overhead of the arbiter having to select among perhaps multiple rules that match. And again, this is something that gets quite lot more complicated and a lot more overhead computationally when in a future lecture we will look at more advanced rule-based systems. I did want to mention one other scenario, so we're going to get rid of the fixed priority. This is a simple example that the only just a tiny bit more work is involved, but it creates a much more capable rule-based system. So we still have an arbiter, but it's very straightforward to implement and we're using data structures that everyone in the class should be able to work with. So the basic idea is that, we still have our list of rules with a condition and action, but we aren't going to immediately return. The first rule that matches we're not going to immediately return. Instead, what we're going to do is we're going to populate a list. It doesn't have to be like dynamic memory allocation list, it could be an array. We know how many rules we have, so we could just have an array that is as long as it needs to be for the possibility that all the rules matched. So that would be a reasonable, efficient solution in many games. So I've got just a little bit of pseudocode here. So imagine we have a list of some sort, perhaps an array of activated rules so that we start off initialized at empty list, and then we go through our rules like if condition, then we will add to this list of activated rules an action with an associated priority. And this priority will be dynamic according to the condition. So this might be like game world state. It could actually be related to the condition or other information as well. So for instance, an example would be, if there's an enemy near, then you could have add an action to the list of candidate rules that you're going to possibly execute. You don't know yet if you're going to, but you could have, let's say, a rule for attack the enemy. So if the enemy is near, we're going to add attack the enemy and the priority is going to be based on health. So we'll say if it's a low health, then it's going to get a low priority because it doesn't make sense for our agent to go attacking if they're badly hurt. We could have another rule that is, if the enemy is near than the action would be to run away. And then we can have the opposite priority, so if the health is low, then we would have a very high priority. And so there could be a whole bunch of different rules that are activated, and then when we get to the end of all our rules, we will just select the highest priority. So that's the extent of our arbiter, is that it's just going to say, all right, there's a whole bunch of rules that were activated, we're going to find the one with the highest priority, and that one is going to be executed. And so this is really pretty straightforward, its simple to implement, only a little bit more work than the fixed priority, I would say and hardly anymore overhead. So this is something that very quick and easy to implement and would be great for simple agents. So either of the two strategies, either the fixed priority or the simple dynamic priority approach both very straightforward to implement. Again, we will be revisiting rule-based systems, so we will look at adding more capability, especially requiring a more complicated arbiter. We'll look at other features like how to more efficiently evaluate rules. You'll notice one thing that came up as soon as we went to the dynamic priority, we had to allow for every single rule to have an opportunity to activate and to assign a priority. So that's, I'd say, the weakness in general for a rule-based system solutions as most of the time you end up having to evaluate of all the rules or a lot of rules and so a lot of the strategy with a rule-based system is making the fact that you have to evaluate all these rules, making that process more efficient. So that's something that we will touch on again in the future, but for now, you have a basic idea of what a rule-based system can be and you can compare and contrast would say decision trees and finite state machines and behavior trees.
