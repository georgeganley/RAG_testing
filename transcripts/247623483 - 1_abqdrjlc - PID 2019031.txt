>> Hello. In this lecture, we're going to look at line segment to line segment intersection. So this is something that's important for completing the homeworks and in particular, creating our discretized spaces. So when you're thinking about two line segments intersecting, in this case, two line segments in 2D vector space, we could either solve for the point of intersection if there is one, or we could just say yes or no, there is an intersection. So in this lecture, we're just going to look at the predicate form that returns true or false, depending on true if there is an intersection and false if not. So we're going to start by looking at the area of a triangle. So you might think what is the area of a triangle have to do with line intersection? And so we'll have to build up to that and then it will become apparent once we define a few things here. But you pry familiar with the equation for area of a triangle half base times height. And then you've may have also seen the vector form, computing the same thing. But if you have vectors defining your triangle, you can perform the cross-product on, say you have a triangle as shown in this figure on the slide. So we have segments A and B. There's a vector A which goes from point A to point B, and then vector B that goes from point A to point C. So if we take the cross-product of A cross with B, then the magnitude of that resulting vector would be the parallelogram that is like double our triangle so from that we can divide by two. So that would be a way we can define it and in terms of the different terms of the vector relative to the dimensions. So the cross-product has to be 3D. So that's why the result here has the unit vector I, unit vector J, and unit vector K. So that is like the x, y, and z dimension. So most of the discussion of creating discretized spaces involves 2D, but we'll see in a minute that that's fine. A little bit about the cross-product, if we don't take the magnitude of the cross-product, there's more information we can get out of this. So depending on whether you have a right-handed coordinate system or left-handed coordinate system, that will define which direction the cross-product in the positive direction we'll go. So we'll use the right-hand coordinate system. So A and B cross together in that or A cross B will result in our cross-product vector going in the up direction. And otherwise, if you flip the order, it'll go in the negative direction. So now we want to work with 2D triangles, again, just the nature of how we're representing our discretized space. So that's easy to do. Its cross-product is defined for three-dimensions and seven, but we have no use for seven dimensions. So we're going to use a three-dimensional cross-product. All we have to do is plug in a 0 for the Z value. So we can have the X and Y components of our 2D position vectors and then just add a 0 for Z. So everything is in the XY plane. And then when we perform a cross-product with these two vectors that both have zeros for their z-value, what you're going to have happen is that your X and Y dimension terms or the unit vector i, unit vector j, they will get zeroed out and you'll only be left with your cross-product either going up or down from the surface. And so everything is in that z-value. So you might notice, to get the magnitude, there's no reason to do the square root of the sum of squares. You can just take directly the z value, the absolute value of that would tell you the magnitude. But we can leave the sign alone. Don't apply the absolute value, And that sign the negative or positive associated with that Z value that we get will prove useful. So now we can define the area of the triangle based on the cross-product by the cross-product, knowing that our Z is 0 and therefore several terms cancel out. And we get the equation that we see here on the top line of the slide. We can substitute in the form for these relative vectors. So each edge is defined by going from A to B. So that would be positioned vector B minus A, that defines edge A or line segment A. Similarly for B we would have C minus A to go from A to C. So we can plug that in, and now we have a new equation for the area that's based on the points of the triangle. So we have the three points of the triangle and we have various terms. And the divide by 2, I moved it over to the area side, so we call this the area 2. And one nice thing about that is in terms of computational geometry. We can leave that as an integer so we don't have to have a floating-point representation. So anything that relies on an area we might generate and save in the form of twice area of the triangle until the last possible moment that we would finally need to really apply the division. Or as we'll see, maybe we're only concerned about the sign. The area itself isn't really important. Now there's some improvement we can make here by reorganizing our equation. And by doing so, we can minimize the number of multiplies relative to the adds that are being performed. And this is beneficial because multiplication on processors typically it takes more clock cycles than adds. So that's worthwhile. But the other thing is when we have 32-bit integers and multiplying, that could potentially be pretty big. That's multiplies are more likely to generate an overflow. And instead, this new form shown on the bottom line, we're performing a subtraction first, which is in many cases likely to result in a smaller value before the multiplier is applied and therefore going to reduce the chance of an overflow. And basically, it gives us a bigger working range of integers. >> He mentioning the sign of the area. So if we have the vertices of our triangle ordered in counterclockwise order, then we can take the area of the triangle according to the form that we've been showing like the A, cross product with B. Again, assuming that our vertices a, b, and c are in counterclockwise order, and we're talking about a right hand coordinate system, then that means that this cross product will always be positive for this particular triangle. But if we had vertices in a different order, then we would get a negative. We can think of as being on the left, or right side. So like from the perspective of A, if B is off to the left, like say if you extend the edge as an infinitely long line. So A becomes an infinitely long line passing through points a, and b, then c is on the left side. But if c was on the right side, the result of A cross with B, would be negative. This is an interesting bit of information that we can leverage. In fact, we can use it to create these well-defined predicates for analyzing geometry. If we use the equation for twice area of the triangle with three points, following along with the form, or the counterclockwise, ordering with right hand coordinate system. So we can plug in like a, b, c with this left value and it would be true. We could use left to confirm that the triangle was in fact, the correct whining for right hand coordinate system, the counterclockwise. We can also have a variant called LeftOn. So rather than testing that greater than zero, we could test greater than or equal to zero. And this will include the possibility that there is no area to the triangle. Which would mean it's degenerate, or perfectly flat. Furthermore, we could test for just equality with zero, and that would be a collinearity test. So a, b, and c are all in a perfect line together. So those three predicates give us a robust way to do lots of different computational geometry building up from these tests, and contributing to other tests or algorithms that we might be interested in, including the intersection of two line segments. We can see how this will be useful, by considering a scenario where you have two line segments, and you want to know how they intersect. So we have these line segments ab, and cd. An intersection will occur, if and only if, ab split cd, and cd splits ab. So you've got to have both of those conditions met, which hopefully you can see from the two figures shown here. But you can use Left, to make this determination for the splitting. So you can create a triangle like c, d, and b, so that you'd be doing the cross product of the vector formed by c to d, and the vector c to b. The cd vector cross with cb. And that would be on the left side, but if you do the same thing with a, you would find a is on the cd, and ca, you'd find that ca goes to the right side because you get a negative value. We could say that, in that case, that cd splits ba. You also have to test the other way around. And what you're looking for is that they're different. So whichever line you're considering as the splitter, you want one call to left to be true, and the other to be false, or vice versa. That is for total calls to left and make a comparison just that they're not equal, or the XOR of each. And that's all you need. That will tell you if there is any kind of intersection which may be sufficient, and a lot of cases for what you need. You may find for certain tests, you really got to make a distinction, between the type of intersection. This can be useful for more advanced tests. The scenario where we were looking at was really a proper tests, but we can separate these out by considering things such as collinearity. If we find say, of course two points of an edge, those are colinear, but what if a point from the other line segment is colinear? In that case, if we have at least one that is colinear, then we've introduced the possibility for an improper intersection. And then you could even have a situation where, the line segments are coincident. So you can separate, or distinguish between these different possibilities depending on how you set up the predicate logic. This is useful. You can make it a proper intersection test and an improper test. I'm not going to go into all of those details, but the code used in the Game AI assignments like the base code to the computational geometry does have this as an implementation. And you can also, if you're interested in more, you can check out the Computational Geometry in C books second edition, with Joseph O'Rourke is the author. That is really a pretty straightforward way of working with intersections. We don't actually have to solve the point of intersection. And it works. We can stay with the integer representation of the endpoints of our line segments. And that makes for more robust code for operations that we would likely be performing when creating a discretized space.
