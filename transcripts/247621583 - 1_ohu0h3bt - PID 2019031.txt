>> So next step we're going to look at some of the benefits of NavMeshes and conclude with a summary. So we've discussed before how an agent following a path network will have to rely a lot on its own intelligence or strategies for dealing with circumstances that might be encountered while following a path. So for instance, an obstacle that gets in the way of the path of the network, maybe the agent is incrementally following the path with some sort of movement algorithm and we're also checking for obstacles, casting a ray to make sure the near term path is clear. And if there's an obstacle in the way, that would mean the agent needs switch to going off path performing some local movement to get around the crate. And this requires a good understanding of the game world environment by the agent in this situation. So for instance, agent is on a bridge and the area to move might be uncertain. So you go to the right or to the left to try to get around. And if you do go to the left, well, if you go too far, maybe you fall off the bridge, but the same circumstance with the NavMesh is that, well, we have a safe known area to test against. We might be able to identify the intersection of the crate geometry with the NavMesh polygon leaves a little bit of space to the left. And so we don't have to look at all of the game world in terms of any analysis for a contingency. We only have to look at the NavMesh and the interaction of the NavMesh with whatever is causing trouble and see if there still remains a path. So it's a much more constrained problem. Much more likely to be reasonable for real-time performance as well. We can also leverage the area representation of the NavMesh, to make adjustments to paths that are followed, maybe supporting different unit types. We can have different offsets. We already saw how we can apply offsets with the stupid simple funnel algorithm with a modification that Horizon-Zero-Dawn used. And so you could make a NavMesh support multiple radius collider shapes to work with the NavMesh. And so supplying an offset similarly that we saw before. And so this shows visually how that might look, so that we have a red path for the infantry and the blue path for the tank. So this can be a useful feature as well. You can also use the NavMesh for analyzing the performance envelope of a vehicle. So you have a very fast moving motorcycle. On a straight line, it goes quickly, but the turning radius is very small. So you might search paths with a constraint of the vehicle performance that's imposed. And the analysis of this is facilitated by the fact that our discretization of the space has area associated with it, that is fairly accurate representation of the full navigable space. And similarly, if we have animated characters run and jump, you'll often have animations that are complicated, especially combat-related animations, so running and jumping. So the agent can analyze whether there's room to perform an animation so they know in advance how far forward the agent would end up moving if they did, say, a running, spinning attack or something like that. That is easy to analyze in the NavMesh. Much more uncertain how to perform that calculation. In the game world as is, you have to identify quickly obstacles in the vicinity and perform geometric operations on those obstacles. It'd be nice if you could work with something much simpler that it'd already been pre-baked into a simplified format. And that's what you get out of a NavMesh, is data structure that's workable for real-time performance. You also get the multilevel support. We talked before about advanced implementations of NavMeshes that you use the voxels to be able to identify multiple surfaces that are traversable by the agent according to their size. And so this is seen, for instance, in Unity. They have a built-in NavMesh. I got some screenshots here from Unity. And so NavMesh has worked great for that purpose. And of course there's well established automated methods to generate these multiple level meshes. So in summary, NavMeshes are very effective for use as a discretized space representation of the game world and serving the purpose of path planning. But also motion planning have benefits over grid lattice and path networks that we've previously discussed. They are however much more complicated to create the NavMeshes, as opposed to grid lattice and path networks. So that's a bit of a trade-off there, but it does have a pretty strong payoff. So you get an efficient representation of navigable space. You don't have the wasted size that a grid lattice would introduce. It simplifies agent movement and path refining such as a string pulling algorithms, which certainly are easier than path networks if you're considering complicated environments that you would likely have in a commercial game. And ultimately, NavMesh is a very popular discretization method, and used in lots of games and especially has become popular in the last several years.
