>> Hello. In this video, I'm going to demonstrate my attempt to create an ordered dither map using physics simulation similar to that what is used in Horizon Zero Dawns in GPU object placer. So the actual dither map was made with a tool external to the GPU work for the live object placement and same with my implementation. So let me switch over to unity here. So I've got a project and it has just a simple little interface. I've got a little tile that will form and it'll immediately drop a bunch of spheres that are restricted to a 2D plane. Let me start that up. You can see the spheres and in the background is the grey region that defines where the tile is. And currently, you can see that the spheres do not fill up the entire tile. You'll notice there's some different colors here. So there's green and then orange and red. The green circles are entirely within the tile region and the orange and red are on the edges. So orange are disks that have just begun to crossover to the opposite side. So you can think of the game Asteroids where you can flood a little ship off the left side of the screen and pass to the right. So that's happening here. These spheres are being pushed off and if they go just beyond the contracted boundary of the tile region offset by the radius of the disk, then it will appear on the opposite side in red. So this orange sphere, we'll think of it as a disk here that matches with the red on the opposite side just so you can see how it just barely over on this edge. And so the red isn't treating just barely on this side. All of the spheres are under effect of a force that's pulling them to the middle. So that controls the grouping. I have some hotkeys that I can hit to expand the radius bigger or smaller and you can see the effect here. So I can shrink them or make them bigger to try to get them to all fit in. And I can also click and spawn new spheres. There seems to be a bug on this computer not recognizing my single clicks correctly. Let me see if I can use a mouse instead of a touchpoint. It still seems to be a little messed up on this. But it's normally supposed to be one-click makes a single sphere. So makes it a little harder to work with, but I primarily do the size scaling. And that would actually be ideal if you're trying to maintain a certain number of spheres. And so once you get to a stable configuration that has good coverage, I can go to the next phase. I hit "Spacebar", and it begins placing the dither values according to the algorithm for generating blue noise. And so what's happening is that you start with a randomly selected disk that has the first value in order of the dither values. So you take the range zero to one divided by the number of disk that you have and that tells you the increment value to increase by as you go through the dither values. And so you can see the values that are set. I have the value map to a color grayscale. Right now they're all very dark colored that you see being placed. So the algorithm works after the first initial disk is assigned, then all the disc are evaluated to see what contribution that single disk makes to it. You can think of it as like a light that's given off. The further it's away, the less influence it has. And so once you figure out the amount of intensity that spills over, in this you actually use a Gaussian function to do that. So it has a blending effect once you add up all the contributions. But after all unassigned disks have been updated with a running total. You don't need to do a weighted average by the way, meaning you don't have to divide each every time, but since you're making just relative comparisons across all the disks, you can drop that step. So you're just figuring out which one has the lowest intensity of all and then that will receive the next value. And you just continue this process on and on. So it's going incredibly slowly now because I have intentionally added a delay. But I can decrease the delay. I'll speed it up so you can see. I'll just keep placing these as always, updating a tally for each unassigned disk to see what the full contribution is and then every time there is a new disk that has the lowest value every iteration through assigning a new one. And so you can see how it does a good job of spreading out the different intensity values. I'll speed it up some more here. So I'll split it up to full speed and as soon as it finished, it immediately went to the next step was doing a test tiling. So it will place the tile up, down, left, right and then the corners as well. So you can't see the tiling. >> Or it's hard to find any distinct repeating pattern. If you look really carefully, you can probably find where the repeats happen. And there are some small-scale patterns, but not any low-frequency patterns, which is ideal for what we're doing and is a characteristic of blue noise. So that there might be some small-scale patterns that appear, which means a high frequency. But there's none that really stands out among any of the other similar frequencies, and there's no low-frequency. Meaning larger-scale structure that you see. If I hit "Spacebar" again, we'll use the same positions, but switches the color just to all whites so you're not thrown off by the different colors. Really we just want to focus on the gradient here. So the centerline of the screen is the lowest probability of there being an object placed. So we've transitioned to the actual test mode to perform the object placement. So think of this like a forest. So we're placing trees in a forest according to a density map. So the density map will have probabilities from 0-1, zero being the lowest probability or the lowest density. Therefore meaning no trees. And then we transition all the way up to one. Currently, there's just a gradient. It's not all the way from 0-1. I think it's 0-0.5 now, but I can hit some hotkeys to change what the full range of the gradient is. I'll start by going down first. So I'm decreasing the maximum value out to the left and right, and you'll see that as it flattens out, we will see fewer and fewer. So we can just imagine that we have a density map that we're using applied to the same space, like a terrain, we have the density method, it overlays the same area that we're overlaying these tiles of the ordered dithering. We just look under the center point of each disk to figure out the probability at that point, and then we test that against the threshold of each disk. So each disk within the same tile has a unique threshold. And so that's what we're testing against. If it passes a test, we can draw the tree or replace the tree. If it doesn't pass, then no tree grows there. And so that's going to vary according to the density map. So you can see I'm working my way down, and this is the very low density here. And then I'll work my way back up all the way, so I'm just spamming this key here to increase. [NOISE] The same gradient is always in place. So I'm just multiplying times a value that's getting bigger and bigger towards the maximum which is one. Once we reach that it should be a density of one on the far left and far-right edge, but it'll stay low probability in the very middle line. But quickly, there's a gradient that transitions to the left and right. So I've hit one now. Again, far-left, far-right, you can think if we can see a visualization of the density map, it would be just a smooth gradient of what we see of the disks. So it would look like black with spray-painted down the middle and then just gradually transitioning from black to gray onto white to the left and right. And then we have a dithered effect of that density map with where these disks are placed. The idea is that now that this tile has been calculated, you would save it out. Maybe some exportable format, maybe like a JSON file or something of that sort that would tell you the positions of each disk. And then that structure could be imported into your procedural content generation for your algorithm, for the purpose of object placement. And so that would be tiled on whatever surface that you want to use, the procedural content object placement, you tile it over the surface, scaled such that the radius of the disks roughly matches the radius of whatever the type of object you want to place. And then you just go through the dithering test to make this comparison. So the probability or the density map versus the threshold in the ordered dithering tiles. So that'll give you your placements. And that is, of course, it is tillable and it's repeatable and you can use it. It's efficient, so it's good for real-time procedural content generation, such as we see in Horizon Zero Dawn. Hopefully, that gives you some insight into a method that can work well for the purpose of placing features in a procedural content generation environment.
