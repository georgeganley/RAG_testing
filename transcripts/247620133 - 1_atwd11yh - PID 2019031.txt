>> The next step we're going to look at NavMesh path node placement. We've already gotten as far as generating our NavMesh in terms of creating triangles, we have perhaps performed merging of the triangles and based on adjacency information, we have identified the graph structure, but we do need to have a position or the purpose of defining a specific path the agent follows and also just support our heuristic for A-star search. So the obvious first approach that we might use is to put a waypoint in the center of each NavMesh poly. So if you do this, you generally will get pretty straight paths, though it will tend to favor going a little bit out of the way, not cutting off corners very effectively. It has also a nice feature that if you're not doing anything to make sure that agents are not getting too close to obstacles will tend to walk in the middle of the NavMesh polygons, staying away from walls so they don't bump into anything. But you can see there's one problem here that is shown with the dark red line. You can see that if the NavMesh is told to go for say, from one node to the next with a line of sight. We actually going to hit an obstacle there so that is a problem, a concern with using waypoints. And that can be worst-case when you have long skinny obstacles. That's actually the situation we have there. They're not long skinny triangles, but more long skinny trapezoids. An issue to consider. We might also choose to put waypoints at the center of adjacent edges or what we might call portal edges. These common edges between two adjacent NavMesh polygons. In this case, the path quality is not too much different than what we saw previously. There's still a bit of a going the wrong way. A little bit the wrong angle initially, and then heading in the correct direction. But we're not, our edges not turning at the inflection point with this approach. And again, this is without any path or thymine new string pulling is occurring. The other thing to notice about this approaches, whereas before when we had any NavMesh poly only had a single node introduced. But now if we have these polygons that are at path intersections, you'll notice that rather than one point, we might have several, as many edges that are portal edges, you're going to have these nodes. Now the nodes do our sensor placed on the edge. That means they are associated actually with to have the NavMesh polygons each. But we still end up with an overall increase in the number of path nodes or waypoints with that strategy. If we put our waypoints at the corners of obstacles, you'll notice that some parts of the path are pretty silly looking, but others can be close to the natural inflection points around the obstacles. Now, this could actually be a problem as well if the edge is bigger than a point or NavMesh is right up against the obstacles, then our edge might get so close to the obstacle or would if it's trying to follow the path exactly they would just bump in to the obstacles. If you were to do this, you'd really need your NavMesh offset from the things that physically the edge could bump into. But there are some nice characteristics here, even though it's a bit silly, like initially in the path, it's getting close to those inflection points. So that brings us to the next consideration that we might combined waypoints at both midpoints of the portal edges and also at corners. And so in this case, we get something that the edge does tend to turn right at inflection points, and also generally has a pretty good path. Just revisiting the problem that was described previously using the centroids of the polygons, where you may not have a line of sight from one node to the next across the edge, if the edge is a straight line. And so if you really want to ensure that the edge can always take the straight line path, you want to put these points on the perimeter of the polygon or at least at somewhere along portal edges for each adjacency so corners or points of edges will ensure that your edge can always take that line of sight paths shown on the left figure. The downside of doing this though, is that you increase the number of nodes and edges that is represented by your NavMesh.
