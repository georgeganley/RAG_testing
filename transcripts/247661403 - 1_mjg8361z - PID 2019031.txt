>> Hi. In this lecture we're going to take a look at constraint-based puzzle games. So these are going to be games that involve constraint propagation for generating different puzzles, but there's some typically unique requirements beyond what we saw at the basic constraint propagation for procedural content, just the nature of some desirable features we want to see in our puzzles. So there are several of these varieties of games such as Sudoku, Nurikabe, Akari, and some others. These were popularized by Nikoli games. And they tend to follow this pattern of being games where the player actually is provided with some clues and the player has to propagate the constraints themselves. So there's a puzzle element to doing so, but a unique feature of this is that the hints provided guarantee that one, there is a solution and that it is not ambiguous, meaning that there's exactly only one valid solution. So one valid configuration, not a variety. And so this is unique to these types of games and therefore the application of the constraint propagation that this has to be taken into account. There are other games where this can potentially be applied. So for instance, the implementation of Minesweeper that you've perhaps played before on one of the old Microsoft Windows releases that did not guarantee that you're provided with enough hints to solve the board. Of course, it was not ambiguous in that case, but you might not have enough hints, but there's implementations of Minesweeper, not by Microsoft, but by others that do follow this role. And it's a desirable feature in puzzles, it's just frustrating to have a puzzle in front of you that's ultimately not solvable or requires a guess like in the Microsoft Minesweeper you might inevitably have to guess and then, of course, the game could end because you guessed poorly. So we've got a set of constraints defined by whatever the rules of our game are. And again, a partial board configuration is provided, those are hints. And typically, at least in the Nikoli style of game, the puzzle designer guarantees that there is a solution, that there is only a single solution. And sometimes we'll also specify that a board configuration provides the minimum necessary revealed values. But that's not necessary, in fact, you can have a variety of difficulties by having more or less hints. But it does, potentially if you're aware of the minimum necessary hints, then that can put a bounce on the difficulty of that particular configuration. So qualities of what might be considered a good constraint puzzles is that the player, through experience they'll discover recurring patterns which can be generalized into applicable strategies for future puzzles. And these strategies also tend to just fit well with human reasoning. They're just the ability to visualize a pattern or a problem and apply it. It tends to follow spatial reasoning strengths of a human player as opposed to maybe something that a computer, for instance, would be good at. So there's a bit of an art of selecting the right constraints. Another feature is the puzzle space should offer a substantial number of unique boards. Hopefully, this would be so many that no one could play through all the configurations in a lifetime. In the case of Nikoli, these appear in puzzle books that you can buy at the newsstand or apps. And they make money off of this, so it's nice if there's so many possibilities that it keeps people busy as long as they're willing to play and pay for the new content. And you don't want to have a situation where you have to make a board that's big enough to have enough possibilities but also gets too difficult. So just a sweet spot of overlap where the board size provides enough possibilities and the constraints limit things in such a way that is human solvable. And then the last feature I would say, the puzzles range substantially in difficulty supporting a broad range of skill levels. So you want to have, in terms of another ideal feature, I'm going to go to introduce some simple puzzles that are easy to solve. These are great for training opportunities, just teaching the rules of the game. And then players can progress and then take on more and more challenging puzzles. And so probably the best known of all of these is Sudoku. Certainly, it's a fun one. I personally like Nurikabe which is also a Nikoli game, just fits a little bit better with my reasoning. But Sudoku is a great one, also is great for explaining the whole concept of these constraint-based puzzles. So in this case, we have this nine-by-nine board, and all the cells in a completed board would contain numbers. And in particular, each row, column, and region has numbers one through nine with no repeats and no numbers missing. For instance, every row and column, you're going to build a find one through nine. And then may be a little bit more tricky part are what are these regions which are these three-by-three groupings. And you can see the more bolded line on the figure shown here where those groupings are, it's also the third of these three figures to see what is considered a region. [NOISE] >> That is all that is defined for the constraints, and you typically a puzzle was presented to you at the player as having just some handful of hints. So some of the numbers are provided to you. And that's your starting point. And then you can start considering the constraints that you're aware of, which are the unique numbering one through nine on every row, column and region. So let's consider this problem from [inaudible 00:08:11] perspective. How do they generate a board? Well, I don't know exactly what their process is, but it almost certainly involves some programmatic support. But let us consider a very naive approach. We might randomly generate a number from 1-9 for each cell, and then just iterate through the rows and columns nine by nine. Just randomly generate a number and stick it in there. So what could go wrong with that? So we're very likely to have mistakes. We're going to not have the correct constraints. We're not performing the collapse and propagation that we discussed before, the general case of constraint propagation. So clearly just that naive approach of trying to randomly generate. If we did that, we might be waiting forever until we can finally find the one that's valid. So a better option would be to perform just the general approach of constraint satisfaction. We're going to randomly select numbers, but for each selection, we're going to take into account the constraint satisfaction according to our three general rules of unique number and rows, columns and groups. And so we're going to select scratch off pass these possibilities. So each cell we might maintain a list of possibilities 1-9 initially. As we collapse, those values become, of course, that particular cell or where we collapsed, that's going to become concrete, that being the only possibility. And then the neighbors related to these rows, columns, and groups, we're going to propagate. Now these propagations can chain together arbitrarily deep. So as you're generating these possibilities, you have to consider the rows, columns, and groups that are intersecting. So keep track of what potentially valid solutions are possible in each cell, and only randomly select from those in future iterations. So you're only ever considering what is in this potentially valid set of values. And so you can do this to completion, where at that point you'll have a filled board. And so it should be a legal Sudoku solution at that point. But you don't have a puzzle yet because now whole thing is solved. So the next step is where we have a valid board, so now we going to make a puzzle out of it. Before we consider how to make a completed board into a puzzle, another option list that's possible in the case of Sudoku is we could generate what would be called a canonical Sudoku board and then shuffle. So this would just be like the most straightforward valid board. Essentially always the same starting point. Just through the most straightforward like 1-9 on the first row and then appropriate generations. From there you can just slide like consider each row like a rolling buffer or circular buffer and then just shift it one over. And so you can generate a board that is valid pretty easily that way, so that can be like your canonical board. And then so, once you have that, you can perform some number of shuffling operations that where the shuffle operation is provable to maintain the constraints. And so there are these constraint games where you can define valid shuffling operations where it's just like provable that the application of the shuffle maintains all the constraints. That's like an alternative approach that one might take. If it wasn't provable that shuffle operation work maybe has some percentage chance of working, then you might need to also integrate in some a validation check. That necessarily maybe a slight variant that could be applied or maybe more suitable to some other constraint games, not Sudoku, but some other type where you might not be able to have a provable rule, but you might have one that's got a high probability that it would be valid, but you just going to do the validation check every time. So in any case, probably, most likely we do the constraint propagation with the collapse and propagation. Once we have our complete board, we now need to start removing numbers until there's enough unknowns for it to be an interesting but still a solvable puzzle. And part of being solvable, it means that it cannot be ambiguous as well, so we need to check for that. So one approach that we could take is a greedy algorithm where we just remove a random number and then analyze the new board state to see if it's still unambiguously solvable. And then we just keep repeating removing numbers and keep giving this check until we find an ambiguity, and then that is our stopping point. A slight variant of this is we could take an optimistic approach where we consider that once we reach the point of finding an ambiguous board state from an attempt to remove a number, well, we will undo the last operation and then iterate through the remaining options in hopes of finding a number that can be removed. And so we'll go through this process and then if we happen to define another, then we'll reset this and then start again with attempting to remove numbers. And then at that point we finally decide, well, we've removed as many as we can. >> This might leave you wondering, at least for the case of Sudoku, is there a minimum board? So potentially, this minimum board would be maybe the ideal form of the puzzle. So the fewest hits would be maybe the most challenging form of the puzzle or the least solved, but at least in terms of brute force exhaustively searching, that would be infeasible just based on the large number of possibilities that would have to be considered. So this has been certainly explored like an interesting problem in mathematics is considering these Sudoku boards. So there is a paper referenced here where some researchers went to quite a lot of effort to try to determine if from the empirical observation of Sudokus that there had been, I guess a handful of 17 number clues. So 17 of the total cells on the Sudoku board being provided as a starting point for a puzzle. So there is some speculation that, well, maybe there is a 16 clue board out there somewhere. So they went through a process with some pretty complicated ways of pruning away possibilities to identify. So at least the results of their work does give us a balance of all possible combinations of boards that there is not a 16-clue board. So 17 would be the smallest you'll ever get. But in terms of the impact on the puzzle, from the player's perspective, it doesn't really matter. And again, you might be able to find a harder version of that puzzle, but there's still so many puzzles out there that it's not really necessary to find the absolute lowest. And it's probably true of many of these types of games that there's really no specific need to find the least configured starting point for one of these boards. So once you've come up with a means of removing values and getting to starting point, you're going to have a board set that's going to not be ambiguous, and you know it satisfies the constraints and you can hand it off to the player and then the player can attempt to solve the board. And it's straightforward to know whether they've got the solution right. It's just a question of evaluating according to the constraints related to the rows, columns, and regions. So we could just stop there and say, okay, we're done, but it would be nice to estimate the puzzle difficulty. So think about the perspective from Nikoli. They want to make these books and have some puzzles to appeal to different types of gamers. And it'd be nice if they could tell the beginning gamers, hey, this is the beginning puzzle or this is intermediate or hard or so on. So how do we go about doing that? So one straightforward option, we could just have a human solve it. Maybe like an expert and they would just train this expert so they can solve any of them, but they assign a difficulty. So if they just breeze through it, that would maybe be the easiest and then work their way up from there. But it'd be nice if we could just totally automate this as well. So we could consider writing a recursive solver. In fact, this is really easy to do. I imagine anyone taking this class could implement a recursive solver for Sudoku, but that doesn't tell us anything about how difficult a human will find the puzzle to be. So how might we do this? And, well, one, it certainly would complicate our implementation, but it'd be nice if maybe we could implement human strategy. So pretty much everyone arrives on the same set of strategies, especially for the most basic steps. It might give them different names, but in fact, if you read any books or websites about Sudokus, maybe after you've played several, you'll be like, well, they've got a name for this thing I've already been doing. So a lot of these strategies you come up with, you generalize a propagation of constraints. It's very shallow. So these shallow propagations and they tend to have these visual patterns to them, something that you can quickly pattern identify. So here's a list of them with the common names that you'll find like only choice rule. And then these go from the simplest to the most complicated. Single possibility rule, only square rule, two out of three rule, and so on. So there's several of these. And if you play these enough, you'll probably discover all of these are almost all. And then maybe you can even read about and learn the remaining of these popular human strategies. So you could write a solver that can recognize these patterns. And this could be more difficult than just a straight recursive approach, but it's certainly doable but I would by your typical undergrad computer science student could implement this. So implement a human solver, exhaustively try the easiest strategy on all cells. And then once you've determined there's no ability to apply that, then you go to the next most difficult and so on. Every time you solve a cell, then you want to reset back to using the easiest strategy again. This tends to follow the human approach. You keep screening for the simplest way of propagating the constraints and then you consider the more complicated ones. And then the whole while you're doing this, you want to do some bookkeeping and track which ones of these you're using. But eventually, if you do this, you will run out of human strategies. You'll have tried them. So what do you do at that point? So this is a situation where you exhaust all the human easily identified strategies. So now you start performing recursive guessing. >> You could just go from there, but if you really wanted to do this for the purpose of difficulty, you don't just want to search for whatever the first possibility is, you really want to do a breadth-first search of searching for the shortest guess that leads to something that you can validate through the rules propagation that you still haven't created something that's invalid in terms of the propagation. This is basically, you find the shortest recursive chain that is either going to definitely solve a cell correctly or exclude a possible candidate number from a potentially valid setlist. And so once you have a valid change to the state of the board, then you fall back to the human strategies again and trial those. It's quite often that once you do the brute force with the recursive approach, then suddenly the easy strategies open up again as working. So you record a tally of all the strategies used, then if you have to use the brute force approach, you might tally that as such, but also what's the chain length that you had to go through to validate it. And so then from all that, you have a heuristic that you based on this tally, you come up with some scoring. So maybe if you're using all the simplest strategies and nothing else, that would be a one. But let's say you had all simple human strategies and there was one hard step, but that was it. Then you might jump from one to three stars out of five maybe. But if you have a number of these more difficult things, then that might boost you, so you come up with some reasonable heuristic for that, and it might not really be a perfect reflection of difficulty, but at least this allows you to automate. Another strategy I'm aware of is from this paper, The Chaos within Sudoku. So these authors, they used a continuous k-SAT solver, so a continuous-time dynamical solver. And they came up with a measure of difficulty based on the length of time that their solver took to come up with a solution. And it tends to map pretty well to how a human might score the difficulty. So this a fairly complicated implementation, though it's interesting in that just even looking at the graphs of how their solver iterates through selecting collapsing different values and how those propagate through their solver. So for very simple boards, you can see that the structure of these graphs, basically, these little graphs are reflecting like this, the selection and collapse and propagation of different values. And so you can see that simple board, there's maybe just one or two guesses. But a hardboard, you can see there's a lot of noise in those. Just necessarily a reflection of just lots of combinations that are being evaluated. And they also had some other visualizations that were showing the parameters that come into play in terms of going through all the different possibilities, and so these easy boards tend to have these very simple structures to visualizing these parameters but the hard ones tends to present these almost fractal-like patterns. And this last picture here, this shows graphs for different boards, or the lines show different boards that were solved. And so I believe when you start off with at the top and the value of one. The board is not yet solved, and then you work your way towards zero. And the point that the zero is reached, just the nature of the way the algorithm works. So after some period of time when you hit zero, that means you've resolved and you have the solution. And so very easy boards, you see are solved very quickly in their time units. And then we see a handful of boards easy to solve and then progressively harder and harder boards. And so they were really interested in finding the most difficult to solve boards. And so you can see that there's some that almost appear to go off the edge of the graph, that you never actually see them curve down to the point where we hit the actual completed time value. In fact, I zoom in on that section to show those hardest boards and try to identify what would be considered the very hardest board. And of course, you can read the paper and actually see the board and try to solve it yourself if you're interested. But some of these just have the perfect combination of values or the configuration, the values are such that it's just incredibly hard with extremely long chains that you have to consider before you can finally say that this is a particular value, for instance. So this actually is very interesting approach and it does a good job, it has a nice uniform spread in terms of signing these difficulties, it doesn't necessarily capture what are the propagations of constraints that are easier for a human because some of the chains that visually you can recognize yourself, just these rules that you internalize, they might involve some bit of depth, I guess in terms of the chains of constraints considered. But they jump out at you and those won't necessarily be captured completely by something like this. But overall, I think this is interesting and it really does a good job of separating out the very hardest from just the pretty darn hard problems. So hopefully you found this interesting, just taking a little bit of a deeper dive into the constraint satisfaction procedural content generation. Because these constraint problems, they do have some unique challenges in terms of generating the content just because the constraints themselves are involved in the challenge for the player, they're not hidden away. These aren't hidden implementation details like generating a 2D level or terrain or something like that. They're actually part of the game, and then we also saw that interesting bit with not wanting the ambiguous solutions because that makes these problems difficult for a human to solve and ensure that they haven't made any mistakes and that sort of thing as they work their way through the problem.
