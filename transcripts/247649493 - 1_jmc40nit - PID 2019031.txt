>> Hello. In this lecture, we're going to continue our look at rule-based systems. So previously, I only went through a brief introduction of rule-based systems, but we will take a little deeper dive this time. So as you recall, when we were looking at rule-based systems last time, we discussed how it is from the era of symbolic AI, and was very popular in terms of academic research, 70s through 80s and continued to be used in all applications, well, into I would say the early 2000s at least, and certainly still applications today. A lot of the work was in Lisp, so many of the examples you will find will be in Lisp because of the list-like nature of rule-based systems. So is not as common in video games though you can find examples of them. And let's say, so we primarily looked at the simplest possible rule-based systems that you can build in the introduction. And so that was to have production rules with a fixed priority arbiter. So basically, there's not actually any arbitration that's needed. So that really simplifies what a rule-based system is if you are substantially simplifying the arbitration. So whatever rule-based system you have, you'll have some number of rules, and they're analyzed in terms of some information, some knowledge, that triggers the rule. And so you have a number of triggered rules potentially, so you might have more than one. And in those cases, there's this act of choosing which rule to fire, and that can be based on a variety of criteria, so we're going to look a little bit at some different possibilities for that. Now another thing that's really a challenge with a rule-based system is the fact that you can end up analyzing a lot of rules and you have a huge number, and there's a challenge of managing the whole system and just the efficiency of how to be able to efficiently update, figure out what rules are triggered, and then which to fire. And it is a problem especially because the rule-based systems tend to become quite large with a large number of rules. So here is a simple example some hypothetical game data. So we now have rules about what an agent does in a combat scenario, so there might be rules about what to do if ammo is low, or healthy or an enemy is near, and lots of other things. And all of those different rules are going to have some condition for which a behavior will be executed. And now this can be indirect as we'll see, but the end result is, at least in the context of the game, is whatever these conditionals are, it leads to agent behavior, and each one is a little isolated behavior. Now, again, of all of these rules, you can have many that are triggered, meaning that the conditional logic is met. So in that case, the arbiter has to make a selection. And so all of this is driven through a database or at least one design of a rule-based system is one that has this database, and that's common of like classic rule-based systems. So when each of these rules are evaluated, then some action is performed on the database like removing some symbol or adding some symbol. And this is synchronized with the simulation, so this is one high-level design that you can implement for a game. So this database will have discretized representations of things in the simulation. Now this might be very close to one-to-one in a lot of cases, so basically no discretization necessary. So for instance, you might have like an ammo count, so that the ammo count in the database would be directly representing the same information in the simulation. But you could have something that is more abstract in the database just for the purpose of supporting the decision-making that the rule-based system is making. So it can also include things that you might consider metrics, so like an enemy sighted. That's not data that is just inherent in the simulation, there's actually some processing necessary typically to determine that an enemy is sighted, so that would probably involve like a re-cast to make that decision. So whenever rules are evaluated, they would be analyzing the database based on whatever information is in the database, and that would have been synchronized with the game simulation. So then the rules are only acting on the database. And then as the rules are triggered and one or more over time is fired, then those will result in changes in the database, and then the simulation will have an opportunity to pick up whatever is changed in the database, and the agent will reflect some new strategy, some new behavior. So when you're working with a rule-based system is like you're programming, but you're just writing these little isolated statements, so it's very declarative. So you're saying that if some condition is met, some constraint, then perform this particular action, which is usually as we just discussed a database, a manipulation, or a database rewrite. There's a mixture of information that is synchronized from the simulation, but also information that there's symbols that are being communicated to the simulation. So these might be like commands that are sent on to the simulation, so you might have say a steering behavior-based agent, and it's receiving these commands that are synchronized from the rule-based system database telling it what target to steer towards perhaps or other behaviors. >> I have an example here of database rewriting that now this is not a game example, but it's pretty easy to understand one. So this is from Nools. And if you're interested in rule-based systems, this is actually one of the platforms you might consider looking at, especially if you're familiar with JavaScript. This is one that I've used before in some web development. But so again, it's a JavaScript rule-based system is based on Jools. And this is just a little diagnosis example. And this is typical of a classic rule-based system, for would be to develop these intelligent systems to do things like medical diagnosis. So the idea is that you could have a huge library of these rules related to diagnosis. And all of them are evaluated and they can be triggered according to patient conditions that are entered into this system. And then it'll spit out a diagnosis. And so in this particular example, we have some different rules about what symptoms the hypothetical patient has. And so for instance, an example would be the patient will have their name, and then we have their fever, which can be normal or high or low. Spots on their skin faults, rash, true, sore throat faults inoculated true. So we might have say and this is a very simple example where we might have a medical record, and information from the medical record would be present here. Then we can have various rules that are based on the conditions that you would find in this patient record data in the database. We will have this and so this diagnosis can be performed. Now, the diagnosis, this is where we have the example of the database rewrite. You can see that there is a, let's see if I can get the mouse show up here. So you can see that for the rule for flu and Scott, the conditions that must be met. So this conditional logic, sore throat, true fever, is either mild or high. And then clause shows that a diagnosis is being instantiated, and this diagnosis is emitted. This is the act of performing the database rewrite rule. So it's inserting the diagnosis and the information related to the diagnosis is going into the same knowledge base. Now, within the same set of rules we have for say, the flu diagnosis, we also have rules related to determining treatments. And so this will automatically be fired according to this newly added data. This is the diagnosis for flu. So if flu or cold shows up as a diagnosis, then we're going to have this emitted treatment that now shows up in the database. Now some point the rule-based system settles down. As you said, you could actually in this case, you would allow multiple rules to fire one after another. So the arbitrary might just go through, maybe picks one up based on a priority or arbitrary condition to do so. But then you keep running the rule-based system so it finishes analyzing every single rule gets analyzed, has an opportunity to be triggered, and go ahead and let it fire. And so you might have multiple diagnoses for, and then also multiple treatments. And so you might have a list of all of them, and submit. In that case, the doctor might have to pick. They'd say, "Well, all of these diagnoses could match, and for you hopefully, it would be a very small number." But the main thing I wanted to show here was how this database rewrite would generally work, and how it communicates with both the rule-based system itself, changing anything. I'm just changing state. And so new rules get an opportunity to be triggered and selected and fired. But you also have communications with some application layer. So they are also reading from this database, and maybe drawing things on the screen, for instance, in this case, or for a video game, the agent behavior would be reflected. So there's another way that we can define this conditional logic in the rules. And probably in the intro, when we were looking at just very simple examples of rule-based systems. You might have thought, well, if there's a condition, then if the condition is met, then just tell me directly tell the agent to perform an action. And so we can either do the database rewriting style that we just looked at or we can do this simpler approach, it's arguably more appropriate for video games of condition action. So we're bypassing the overhead of managing the symbols in the database. So if we have a rule related to throwing a grenade. If enemy near throw the grenades so were just directly telling the agent to perform the action. So there is a preference in Game AI, and in game implementations to do more of the condition action forum rather than the database rewriting. Because that involves a lot of dynamic data structures, these lists, it means that you're probably performing memory operations on the heap. So that means using the new keyword to make newly allocated bits of memory that then have to be freed either manually in languages that require it or garbage collection is being hit. In either case, having a lot of memory operations that are typical of dynamic data structures. That's probably not something ideal for games. >> So the downside is that the database rewriting allows for complex data processing we just saw an example with the diagnosis where the rewrite system can track state internally. And you could probably still come up with ways to send the data on into the game world in some fashion or maybe you have highly specialized rules where you have maybe some fixed data structures that can track some intermediate information about rules, but that's going to limit you, you're going to lose out on that flexibility. Now you can also have hybrid approaches. So you create specialized methods, is basically what we're just talking about. So execute is part of an action. And then the results are reflected in your game state. So you can use both approaches to be able to synchronize. Whatever you're trying to do. Either synchronizing with state type information so that future rules can act upon or that the game itself, the agent on the game side can form whatever behavior is necessary. So in terms of representing information in our game, we're going to have declarative knowledge. So these are stable facts about the world. And in the classic list like presentation you'll have these attribute value pairs. So you might have some attribute like the captain weapon and that would be related to well, what type of weapon does captain have? And then that would be rifle or machine gun or whatever. So that value can change according to the state of the game world. And we can also have values that are nested knowledge. So this is enlist. These are lists inside of lists. So Captain weapon and it could have a rifle, but we have a list that is an attribute of rifle, and then that could be ammo 36. So that's telling you basically that the rifle has 36 bullets. You can also have state-like information that is may be related to say, a steering behavior that your agent has or an animation, so action defend or go to location. So the go-to location that is referencing a path planning and path following combined into one. So this ability allows the rule-based system to become like a state machine because it is defining different behaviors like riding into the databases, different knowledge. So here we have an example with different facts about a game scenario with squad combat. Say you have some different soldiers and they're working together in some war strategy type game. So we might have attributes related to the health of each of the squad members, and then also what item squad members are holding. And we might have an attribute for that, or weapons or ammo. And so all of these attributes is the declarative knowledge that can be used for triggering the rules, whatever the conditional logic is for each of these. So our database, it holds all of this knowledge and we have some external process that this job is basically to populate and update the database according to the World states. So maybe every frame or some determined rate like a tic related to this AI processing. We'll go through and inspect game world state, do any data conversions that are necessary, run any metrics that are associated, that are not directly represented in the game world. So these are also called probes. And so you might see a problem here is that there's no structure to how rules get executed in a rule-based system, at least that we've talked about so far. So unlike, say, a decision tree where we only need to execute our probes or metrics for the rules that are applicable or similarly with a state machine, only the things necessary to determine transitions from the current state do we need to evaluate. We need to evaluate all probes, all metrics, any expensive processing necessary to evaluate a rule. Well, infact if you have that rule at all in your set of rules, then you have to do all the analysis necessary to populate the database and keep it up-to-date. So clearly, this sticks out as something that's detrimental to real-time video game performance. And so the agent's going to need to have some automation in place that gives it ability to perform the actions that are identified by the rule-based system. So the rule-based system is going to be updating the database with declarative knowledge. And that's going to serve as a signal to the agent to act upon whichever rules had fired. That's going to tell the agent what to do. And so that external process is going to be critical here because it's going to discover in the database that there is this statefull message that's being sent to the agent and it's going to actually pass that data along appropriately and then the agent can actually perform it. So you're still going to have to have some additional smarts that the agent is going to have. It's going be a more on the order of playing an animation or running a steering behavior, maybe interfacing with path planning. Yesterday age was going to perform these actions and the results are going to be modifying the declarative knowledge because if the agent performs actions, that's going to modify the game world and these modifications to the game world are going to change. Similarly, the rule-based system could, while the agents in the middle are performing any behavior that it was originally instructed to do, the rule-based system could change deleting that command from the declarative knowledge in the database and adding a new commands and some new behavior that the agent is going to be performing. Then we have procedural knowledge is knowledge about how we do the things we do. And so it's basically what is the action that is being performed. >> The If-clause contains data that needs to match according to whatever is defined to be, so like whisker's health. One of the soldiers we might have to match against, say, whiskers health. So that's going to be joined by a Boolean operators perhaps with some other conditions. So that's going to lead to different actions that we want performed by the different agents. So we can have a whole bunch of different rules that each refer to a specific object that is found in the game world, that's represented in the knowledge. Now, if we have lots of different agents or characters in the game, we might end up in a situation where we have similar logic running over and over again. So we might have a rule for whisker, his health and what to do if his health is low, or if the captains health is low. We might have the exact same logic related to both of those separate conditions. So it can get rather tedious to have to write if whiskers health is less than 15, and if captain's health is less than 15 and they're both identical rules other than the names. And if we have to do that for some arbitrary number of characters, that's just going to be a waste of all of these rules. I'd be much more concise if we can use some wildcard variable that could represent anybody. In fact, that's something that's very useful in rule-based systems, which we'll look at in a second here. So we have the components, we've got the declarative knowledge of facts. We have procedural knowledge which are the actions. And I'll often, the declarative knowledge and procedural knowledge co-exist together in the database. And we also have selection knowledge. And this knowledge about the way in which we're selecting roles. Part of that is just the conditional logic of the rules themselves. So like what are the Boolean criteria? But then there's also the arbitrary which is important to the selection as well, and so the arbitrary will have some knowledge about what to do when there is an ambiguous situation of multiple rules being triggered. Which one is it that should be fired? So that's part of the selection knowledge. So the arbitrary can get rather complicated. We've seen some simple approaches in our brief introduction previously. So we could have first applicable or fixed priority. This bypasses the need for an arbitrary at all, it's just implicit in the rules. You go through them in order and the first one that triggers is immediately fired. So there is maybe some potential for average performance if not needing to analyze all rules you will perhaps find one that will be triggered more often. Though the way that they're often ordered is, you have most specific conditions first and more general last, to Makes sense that general conditions are perhaps more likely to be evaluated. So maybe you still are evaluating all of the rules, but it'll depend on how they're organized and just the nature of the problem. There you could have at least recently used strategy, you could just randomly select rules. We've seen a simple dynamic priority system, example in our introduction where we had some condition that would be evaluated. If the rule is triggered, then we would have some metric that would result in a priority. So we would track not only the fact that the rule is triggered, but it's triggered with a particular priority. But in this case, we have to analyze all the rules and see which triggered, and then we want to sort according to the priorities and pick the one with the highest priority. So that can be pretty effective. And there can be other ways that you might go about setting these up, dealing with situations with like trying to avoid selecting the same rule over and over. So maybe some history or stickiness to rules that maybe over time they eventually get replaced with some other rule. And that might be something that would be important in video games to do that strategy or anything with a real-time simulation aspect to it. So back to the issue of needing these wildcard variables. So this is in the context of rule-based systems. This is called unification. And it's basically a notion of binding of variables into logical statements based on whatever these wildcards are. So a convention in some of the lisp, like rule-based systems is to represent with question mark and a variable name. And so those are the wildcards in our rule-based systems. So person for instance, could be replaced with the name of one of our characters from our squad. So we might have any of the names that we saw before could be placed there. And now you match them. If you have a complicated Boolean sentence as part of your rule, you might have further parts of the Boolean clause refer to the same variables. And we have an example here on the screen. So the question mark, person health is one attribute that we're looking at. And then there's and, radio held by question person. And so that person, it matches in name. So these can't be two different people. It has to match. So you might plug in the name whisker on the left side of the end also whisker on the right side of the end. And so in that case, we would have to have the attributes that may be related in both parts of the clause, but it would need to fully make sense otherwise that unification strategy, the expanding the wildcard, it would fail. You'd have discovered that there's not further information or attributes that would allow it to evaluate to true. So you would abandon that one and then you'd maybe try the next name and so on and sit to see which ones are triggered. So this allows rules that can match in many different situations. It allows more concised rule writing because you don't have to replicate rules unnecessarily. It does impact complexity. So you've shrunk the number of rules, but it's going to be related to the number of items in your database. And then m is the number of clauses in these patterns that need to be matched. So we have big O into the m. And so this is something that's going to limit our use of the wildcards because we're going to have to exhaustively analyze so many different possible bindings in order to find rules that can be triggered. So the algorithm though, is very simple to implement. You'll just go through your database and determine these different candidate bindings. And then of those bindings you'll evaluate with each of the rules and then you'll be able to figure out if we're going to trigger the rule or not. Now, again, this is very simple, but it is problematic in terms of scalability. Instead, there's been a lot of interest in terms of improving upon this weakness, the lack of scalability. And so one popular approach that has been effective is the [inaudible 00:36:47] algorithm. So this is an approached for rule-based systems to perform efficient analysis of roles, especially when we have this variable binding. >> If we're able to efficiently analyze the different parts of the conditional logic, the Boolean sentence part of the condition and the bindings that are related that we might have present in our rules. If we can do all that efficiently, then that might improve things for video games, especially where we have real-time performance needs and any other system where we want the system to be able to quickly return different results and be very responsive. So what RETE does is it is able to analyze all of the rules, looking for the patterns in the rules and related structure between multiple rules. And it restructures everything into a directed acyclic graph that has pattern nodes, join nodes and rule nodes. And these can be used in a way so that they're sharing data between the multiple pattern nodes that feed into joined nodes, is what we'll look at in a second. So this means that we're not replicating as much work. There's also the ability to preserve previous work. So if this is say, built into a game event loop, that from moment-to-moment little of the information will change. It'll probably be the same as it was the previous frame for the vast majority of the data. So that is something that works out well with the RETE algorithm. So with this directed acyclic graph, we've got these different patterns and we can very quickly match to figure out, well which rules are going to be triggered. And then if changes are made based on a fired rule, some changes of knowledge that either feeds back directly into the rule system or causes some behavior change in the game world. And then whatever that result of that behavior in the game world changes things. We're going to have these graceful incremental updates to the data that's cached in the directed acyclic graph. And is still able to work fundamentally the same as your typical rule-based system where all rules are analyzed and given an opportunity to trigger. Now, one concern raised in the Millington book and this being true of any algorithm that might be proprietary and part of a patent is that you should always be cautious about using it in your own implementations because it might be in a situation where you have to pay some license fee. So even if it's something that you write from scratch based on a description, even like say in Millington's book could have an impact on the products that you develop. And so RETE is an algorithm that is associated with proprietary and patented algorithm. So we'll continue looking at the Millington example with the military troops. And so this is a RETE example that involves some behaviors that you might have your troops perform that is strategically advantageous. So we might say certain troops have radios and the radio in this game is important that the radio stay operational for communication purposes. So you don't want someone with a very low health to be holding a radio because if they become incapacitated or you're killed or whatever, then you no longer have that communication going between all the troops. So there is this particular role here that says, if p1 health is less than 15 and p2's health is greater than 45, and also that the radio is currently held by the p1 agent. In other words, if p1 is hurt badly and all happens to be holding the radio, but also in his group is a Player 2 that has good health, or reasonably good health. Then we want to do is swap the radio over. So in terms of representing that swap is done symbolically in the database as a database rewrite. So the first we have a write of removing the radio. Again, this isn't actually realized as an immediate behavior. A symbol is removed from the list of knowledge. And then we're adding a new symbol that reflects that the radio is held by p2. So again, we need some external process to the rule-based system. It synchronizes this information with the game world to the agents. Maybe we'd play an animation of handing the radio off from one to the other, perhaps would be a way to do it. Then there is also another rule, change backup rule. And so this is related to Cover Fire. So maybe this would be like one of the troops is say, hiding behind a barrier but firing bullets on the enemy position while another player is moving about. So again, we have these wildcard variables that's reflecting the need for the unification strategy of being able to bind one of the characters to p1, but still meet all the conditions in the Boolean sentence. So if p1's health is less than 15 and p2's health is greater than 45, and p2 is covering p1, then remove p2 is covering p1 and add p1 is covering p2. >> Basically, this just means swap strategies. If you have someone badly hurt and they're maybe doing something in a dangerous position while p2 is hiding behind a barrier, and providing cover fire, then we're going to have the swap rules because the one that's running around unprotected is so hurt. That make more sense to swap them around. So you can have lots of these rules and all reflect the need for these wildcard variables and need this unification strategy. So Rete again, as I directed cyclic graph, we're going to end up with something like this. So you'll notice that we've lost the ands. Let's go back again. So we had four different ands, so we had p1 health less than 15, and p2 health greater than 45. So in these two example rules, you'll notice that for the swap radio rule and the change backup rule, they both have parts of the same conditional logic. So we can break that down into individual pattern nodes. And so the pattern nodes are just the smallest pieces of those Boolean sentences. So what's on either side of the ands, and it could be ors and other types of logic as well. So this pattern nodes are then linked to join nodes. And the join nodes that reflects this Boolean logic that was removed. So those with themselves that each of the join nodes would be like an and. And lastly, those feed into the appropriate rule nodes. So whatever the condition that leads to the behavior or the database rewrites will be at the bottom in the rule nodes. So here you can see that by generating this graph structure, we've identified common uses of the same patterns in the rules basically. So little parts of the rules represented these pattern notes. [NOISE] Now these facilitate efficient analysis of the rules because we can make these determinations just once and then they can be shared. But then there's also a lot more going on involved in running these rules. And that's because we have unification possibly occurring, so you'll see every single one of these rules has a wildcard variable, and those have to be bound to different possibilities. Now, in this case, each of the pattern nodes, they exist there in isolation. So say for radio held by p1. We could look at all of the troops in the game currently that are on the players team, and we could figure out all the ones where this attribute is true. That'll be any player 1 that has a radio held by them. So that might be a few different names. We could associate that information with the pattern, and then we might similarly look at all the characters with a health less than 15 and that's going to be a different list. And then that information since basically we are going to have lists of qualifying information at the pattern node. And then this is going to go down to the join nodes, and depending on what the Boolean operation is and where it came from, we're going to find out if those bindings work or not. So we're going to remember what variable is bound to. The furthest left pattern node shown here, it's going to be bound to the name p1. So that p1 name is important because it's going to have to be matched as information propagates down the join nodes. What's going to happen is these lists of the started originally at the pattern nodes. You might have a longer list, but as it bubbles down through each of the join nodes, you're going to be removing parts of the list as it joins with other list bubbling down because variables don't match. And so you're going to probably get to a smaller and smaller set of candidates, and then finally determine if any of the rules are triggered. So we might have an example of Captain health 57 is covering Johnson. Johnson health 38, Sale health 42, Whisker health 15 is covering Sale radio held by Whisker. And so you can go through this as an example and you can consider all of the different bindings that are possible from this data in the database, which is shown here on the left, all those things that I just read off. That's our data that's in our database. So we can look at each of the pattern nodes and figure out, well what could we bind to say p1? And well, there's only one holding the radio, so that's Whisker. And then we could look at the health less than 15, what bindings are possible? And so that's again Whisker. Health greater than 45, we can only bind captain for p2. And then we have p2 is covering p1. And we've got two different possibilities. We can either bind Johnson to p1 with Captain as p2, or we could bind Sale for p1 and Whisker for p2. We have all these different possibilities, we're going to bubble those down to the join nodes. And so we're going to analyze whether there's any conflicts that are occurring at this point, and if not, we just join them together as all of the possibilities that will go further. And then at the lowest level of the join nodes, we're going to see that those are leading directly to our rules that might be triggered. And so you'll see that the only possibility at the lowest level is for p1 to be Whisker and p2 to be Captain. And that means that the swap radio is triggered, and so at that point it can be selected and fired. So the database is fed into the top of our reading network. Pattern nodes find the matches in the database and they pass them down to the join nodes. And when the wildcards are used we'll have this variable bindings. So again, you need both; what fits into the variable and you also need the name of the variable. Those two pieces of information are critical because otherwise the join nodes won't know how to analyze and determine whether to exclude or not. So the pattern nodes are going to keep track of whatever the matching facts were. This is going to be for, say, a video game, these are going to be preserved and whatever match the last time that's going to be remembered. And it's just going to wait to see if any changes need to be made. So if the game world state is changed, if it's only just a couple of things that change, then only the patterns that are affected will be updated. If they are changed, then only those get bubbled down. And so you can still preserve all of the other information for the other nodes. So this is really the key aspect to Rete that has the big performance gain is that you're able to cash all of this, of course, you're going to have the cache memory caching requirement to preserve this information. There is going to also be the the bookkeeping cost that if you have say a lot change, you're going to have an extra overhead of trying to figure out, well, what to update or not when you might've been just better of updating everything. So it really does rely on this assumption that you're going to have very little change from update cycle to update cycle for most of your pattern nodes, so it will have less change. >> That is very useful now the join nodes are also part of that caching. Basically, join nodes job is to make sure that everything matches and it'll have usually like the AND logic or OR you could possibly have some other Boolean logic like an XOR. And yeah, that's really key to the system in terms of collapsing together all of your different rules, the conditional part of the rules. Once you get to the bottom, It's very much like your typical rule-based system because the rules are going to be triggered, you still need to have the arbitrary that's going to determine which rules will go on to fire. But again, the whole system will, once as changes are made, if anything changes in the database the next time, we're just going to have this potential for the incremental updating. So we already talked about how all the nodes store whatever data they were last analyzed with all of that is cached. And they'll respond to any bubbling down of new information. And if they change from what they previously had, they will bubble down. If not, there's no reason to have that effect, anything below it. And so again, this allows things to work very efficiently. So that closes out our look at 3D. But even with reading, we still have problems with really large rule sets to the point where we might be looking at further optimization. One solution is to not always have all roles being evaluated at all times. And you can do that by having some groups of rules. And so maybe one group would trigger, may say, write to the database some change that says load in this new set of rules for the next time an update is perform. So this is adding like a state machine like aspect to the rule-based system. Say that one set of rules can figure out its, something's happened and it needs to go on to a new strategy. And so there's different approaches in different APIs for rule-based systems. Like in joules, this is called Agenda groups. You might see other approaches in different rule-based systems. An example we can look at is right here. We have some different strategies, perhaps for combat in war-type game. So we might have started with a master set. So this basically set a rule. Only job is to enable other sets. But that doesn't mean that it's the only one that's allowed to enable other sets. So we can't have a hierarchy where the master set is the root and then it identifies some state information, some conditional leads to the loading of this new activation group. Maybe you have one for defense or offense or networks and so we have the possibility to transition to these different steps sets or transition into sub strategies within a set. Like offense might have melee combat, or missiles. And those are selected again according to whatever the state is. The game world that's shown in the database. One interesting thing about rule-based systems in some of the other of the classic symbolic AI. Decision-making strategies is justification of action. And so be as important in games though, I'm sure we could come up with some scenarios where it would be useful, but because you have these well-defined rules that are being fired, we know exactly what the conditions are that lead to a rule being triggered, what the conditions that led to a rule being selected and fired. And we have maybe a whole chain of things that occur, multiple database rewrites that occurred in sequence according to some initial condition and lead to or resulting action that's being performed. If you have all of that information, you can write to a log and have very detailed account of why something is really important in something like an expert system that's doing diagnosis for medical condition. You want to be able to say exactly why something was done. Because it's life or death. Now in a video game, maybe not as big a deal, but perhaps say, a strategy game that we're, maybe the player is able to select from different strategies. Maybe indirectly interacting with different sets of rules that are being selected. And resulting behavior occurs. And so the player might be interested, well, why did the agent do whatever they did? Maybe the role-based system could just tell the player and you could take the audit that this justification of action audit and present it to the player and maybe come up with some appropriate and game-like way to show that to them. But then that would inform them and allow them to say, adjust their future strategy, their future selection of actions. >> As for 3D efficiency, there's a big improvement here. So we have big O of n times m times p. So we have n is the number of rules, m is the number of clauses per rule, and then p is the number of facts in the database. So this is really a big improvement. And then average improvement can be pretty big as well because we have that caching that is going on at each of the nodes preserving. Now, if you have lots of unifying with wildcard variables, that can take over in terms of efficiency impact if you have a large number of these wildcard matches. Now, there's a bit of a trade-off as well because we have memory usage that is going to be increased because of the caching. So the trade-off is we're using the caching to buy our time performance. Advantages of a rule-based system is that it allows for something that has a bit of improvising to it. It's not quite the same as a goal-oriented planning such as A-star planning. So we'll talk about that soon looking at if an agent is modeled from the perspective of goals, how we might be able to plan through a number of different possible behaviors defined with pre and post-conditions. And then those would lead to different plans or sequence of behaviors that hopefully, lead to a goal. The rule-based system, the fact that we're analyzing all of these rules collectively can allow for some improvising. We can have rules that get triggered and fired in ways that would never occur. Say, with a finite state machine, only a small number of the transitions are considered. It's based on what the current state is in the finite state machine. So this can really allow for some more dynamic behavior, but obviously, we have this cost in terms of efficiency having to analyze all of the rules as the performance here is the trade-off there. And certainly, rule-based systems is another means of creating reactive behavior selection. So downsides, you have less designer control because you could have these unanticipated reactions. And it's just this declarative process of writing rules like, in this condition, the agent should do this, and in this condition, should do this, and so on, but you can't really tie all the rules together with a cohesive plan. It can be very difficult to debug because you never know what rules exactly are going to be triggered, especially when you have the side effect of triggered rules resulting in your database rewrites and also the resulting behavior in the game world and that feedback loop. So it can be very difficult, very challenging to debug and figure it out. Making sequences of behaviors is also something that is difficult. Certainly, there's possibilities there based on the information that's being stored in the database or stored in the game world as a result of a behavior. Could track that information, but it's indirect and puts probably an unnecessary burden on the developer to try to do this where it's much more natural in, say, something like a behavior tree. Certainly, rule-based systems have a reputation for being inefficient, and also challenging to implement because of the challenge of the inefficiency and trying to come up with ways to make it more efficient. And then also the authoring of the rules in that declarative fashion. It's in a level of indirectness, I would say, from defining these different rules in isolation. And then hooping that collectively when they're analyzed all together that you get the desired or intended behavior. You can get similar reactive decision-making to decision trees and finite state machines, which if you think about it, decision trees of finite state machines, it's a little bit more direct in terms of what you're trying to do. It's more procedural, but you have more direct control over the end result as compared to the indirectness of the rule-based systems. So, therefore, you might be thinking, why would I want to go to that much trouble? And I think really the main thing that might lead you to want to do that would be if you, particularly, are looking for some improvisation, or if just the nature of the problem you're trying to solve, you have little nuggets, little bits and pieces of things you know are the right thing to do, but you don't really have this cohesive strategy on how to tackle whatever the problem is overall. This might often be true of something like a strategy scenario. Well, you know little bits and pieces of strategy, but telling troops exactly where to go and what to do, that's not always going to be something as easy to do. So there are lots of resources out there for rule-based systems. I've got some information that was collated by another lecture. And so there's a few different links, information on drools and the related OptaPlanner that you might want to check out. Many of you are also familiar with Russell and Norvig, both artificial intelligence, some modern approach. And so in that book, there is a bit of discussion about rule-based systems. And so there is a project on GitHub that has some Java implementation that you might be interested in. Then let's say here is a little example of Jess. Actually, I forgot to put the link in here, but you might want to Google Jess too. That's another system. Then the last system I'll mention is Soar. And so this is another that is very popular and it's even been used for game AI before. So this is a production system and it's based on a theory of human cognition. And so it's really meant to be a platform to support all modeling like simulating human cognition for purposes of agent behavior or decision-making. One example of the use of Soar several years ago now was for Quake 2. There's a bot built with Soar to play Quake 2. That is no longer available, but you can find discussion of online. So Soar, it was developed at CMU by these researchers; Newell, Laird, and Rosenbloom. nd so that is part of a very well-known work by Newell, the Unified Theory of Cognition. And this took several decades to develop and it's been used in a lot of different systems. So if you're at all interested in rule-based systems, you definitely would probably want to check out Soar as well. So that wraps up our look at rule-based systems.
