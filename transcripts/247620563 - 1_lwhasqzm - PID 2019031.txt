>> The next step we're going to look at expanded geometry, so with the NavMesh. You generally have your polygons of the NavMesh right up against the obstacles and so this can create problems in terms of the agent moving around within the NavMesh. They might actually bump into an obstacle. But if we could somehow shrink the NavMesh or rather expand the obstacles, then we can then end up with a NavMesh where the agent can safely move to any point within the mesh and not bump into anything. So the basic idea is that we look at our agent and consider the radius of the agent. In many cases you would represent an agent with a collider shape that is a circle in 2D or in 3D would probably be a cylinder or a capsule collider, looks like a tic-tac, and stays vertically oriented. So if you project that down onto 2D, which is generally how we think about movement for AI as a 2D problem. So in all those cases, we have a circle that we're considering moving around. So we can use that radius as our offset when the geometry is expanded. So if this is expanded before you create your NavMesh, you're then working with your obstacle boundary and obstacle vertices, the points of the shapes. We'll already include that offset, otherwise you're building the NavMesh just as you normally do, you're just adding this extra step of performing the expanded geometry. And this can be accomplished with other discretized space representation. So for instance, the pictures on the top of the slide show using expanded geometry with a grid lattice. That just means that more of the cells of the grid would be marked as being untraversable. In terms of performing the expansion, there are different ways you can pull it off. So I've got a figure here that's shown. This is from the Clipper library. A library is actually used in the NavMesh Game AI programming assignment. And so if that library performs the union of obstacles, eclipse them to the boundaries of the world and it also performs this geometry expansion. So this is all already done for you with this library so you don't have to implement this yourself in the class. But it's worth considering the challenges of creating an expanded geometry. The big issue with expanded geometry really is the corners. So you might think that there wouldn't be as difficult as it is or would have serious implications to just take an obstacle and then move all the vertices out away from the object. And just conceptually, maybe it would seem simple at first glance. But let's think about ways that this could be performed. So one is we might expand the edges, we're exploding the object apart and pushing the edges all outwards. And so in terms of steps, well, each of the edges of a polygon have a normal that we can calculate and that would allow us to set a direction to move the edge out. Of course, once you move all the edges outwards, we're going to move them by the radius of the agent and that's going to leave us with these disconnected edges. Then what we could do is we could grow out all of these edges and then grow them out to the point that they intersect with their neighbor edges. Actually, we could just find the infinite line that goes through the line segments of each edge, and then find those intersection points and these would be the new vertices of the expanded edges if we performed that operation. Now, that's straightforward with convex objects. It would get a lot more complicated with concave objects because as you're expanding in concavity part of the polygon, you might actually have one edge expand into the other, such that you may be even just totally erase the concavity and it would become a convex object. It expands so far that details disappear. In that case, the algorithm gets a bit more complicated but certainly, something that could be handled. But what I want you to consider is the figure at the top here. So we've expanded all the edges that push them away by the offset and grown the edges until we find these new vertices. So it looks okay on the left side of this long skinny triangle and we can see that our agent depicted in green that at least along the edges were exactly what we want. In terms of the offset, the center point of the agent can go right up to the edge of the red and just be grazing or just off of the actual obstacle geometry. So this would suggest that would work well. But look at the corners, so the corner on the left is, if you put the center point of the agent right on one of the two corners on the left, one is shown in the figure, we see that there's this little bit of space there. It's not too bad, but clearly there's some error and that wouldn't be so bad if that's the furthest you ever have to deal with but notice that as we have a much sharper angle, the point of the triangle to the right, when we perform that edge expansion and then found a new point that connects those two edges, well, now we are well past the radius away from that point and so if we place the agent center point right on the tip of that triangle, it's nowhere close. And so if we expand it like this, it could create some real problems in our NavMesh and maybe even cut off connectivity in the NavMesh. So that's the problem. Another approach we could take is to say, well, instead of expanding edges, we could expand vertices, and so in this process, while we find each of the vertices, well we need a direction for it to go. So we could just look at the two neighboring edges that are connected at that point and so we've got a normal for one edge and a normal for the other, so we can take the average normal. And so that is going to point it bisecting outward direction of that angle, starting at that point. So that would be the direction that we move our vertex. Of course, we still know where all our edges are connected. And again, we would have potential cleanup to do for concave polygons, but it is a straightforward process that we could perform to follow this implementation. And well, that'll work fine at the corners as we can see shown in the figure of the agents. If it's placed at the corner it is clear, just clear of the corners of the obstacle. But then look at the offset from the edges. Now, the offset is not nearly enough. Neither of these two naive strategies are sufficient. What really you have in terms of situation at least for convex polygons, is if you blow up and expand the edges, not increasing the length of them, but just move them all outwards. You still remember which edges should be connected. Well, then you have a radius that connects curvature, it's not a point. >> This means that you no longer have a polygon. Assuming that we do want polygons and that is a reasonable thing to want in a video game in terms of the graphics hardware and the computational cost of determining point containment or intersections and so on. We don't want to be dealing with any curved lines in terms of representing the geometry. So instead we need to convert it to some kind of polygonal representation. So we're going to introduce some error. It's not going to be perfect, accepting there is a compromise. There's different strategies that you could use. You could do a squaring off of the end or mitering. And this basically is making some determination of when and how much to cut off. So one thing you could say is within a certain error, we're not going to perform any manipulation of the corner, so we expand the edges and grow them out as in the first example and we'll just say we'll measure from the original obstacle point to the new expanded point. And we'll say, fits within 1.5 times the length of our expansion radius. We'll leave it as is. But if it's any further then we will cut it off. That's the feature, that's built into the clipper library. I forget the exact details right off the top of my head. The difference between squaring and mitering, but I think one is selective. Then there's also selective, meaning there's a condition like the 1.5 distance. But then there's also this rounding option. So knowing that the radius curve is really the correct way to reflect that equal distance expansion of the geometry around the neighborhood of the point. You can tessellate that radius curve at the point. That's what the rounding does. And so you can tell through some configuration of clipper how many segments should be part of the tessellation and whether it's based on some dimensions in the space. So maybe if it will say that if any line segment is longer than a certain length, then it would subdivide further. That sort of thing. Again, this is all a compromise and you can get reasonable workable results. Now there are some implications with Navmeshes when you expand and say use JT round. That's a more precise definition for the boundaries that the agent could go. But you're introducing a bunch of vertices that you're going to be using for your triangulation. That can especially have a big impact on the naive greedy algorithm with this poor performance of triangulation. But even if you have a better algorithm, you're creating probably lots of tiny triangles around a radius that's been teslated with a really fine resolution. You really want to find the right balance like what's appropriate, how many points? It's probably going to vary based on the exact geometry and the radius of the curve and what impact it would have overall. These are parameters that you would need to tune appropriately for your game. So expanded geometry is very well-suited to improving Navmeshes, but it also works with other discretized spaces, even path networks. You could use this for an interesting, in that case, you would not need to do the point distance from line. And that's because as soon as you expand the geometry, your definition for the agent changes, you're no longer thinking of the agent as being like a circle, a point with this radius distance that it needs to be separate from everything. You now think of the agent as being a single point. This for runtime performance, this is great. So you've moved a lot of the computation to preprocessing this bake that occurs before the game even runs. You've generated this information that allows you to change the definition of the problem into a simpler problem. Now at runtime in your game, you don't ever have to worry about the agents distance from the obstacle boundaries or the Navmesh boundaries. You just think of that as a point. And so of course, there's a great performance benefits there when you're trying to maintain a high frame rate. In terms of planning where the agent can move on the Navmesh, what places it can occupy? Well, you know that the agent can be anywhere within the boundaries of each convex Navmesh polygon. And if you want to know where the agent can go, maybe across multiple polygons, you can cast a ray within the Navmesh data structure. You just cast the ray. The ray doesn't count as intersecting across portal edges. But if there are barrier edges, meaning there's not adjacent Navmesh on the other side, those are the barrier edges. Those would be the only edges that count against the re-cast. That's sufficient. You don't have to worry about whether the agent fits or not because it's a point. If there's a portal edge there the agent can go. Also, I wanted to mention that the problem of expanded geometry is somewhat similar to the issues discussed about the points of visibility for the path network. So in terms of inflection points, the inflection point isn't truly a single-point it's actually a radius. And that is because of this issue. If you think about like sliding a circle, circular shape, like what's representing our agent. If you try to think about sliding that around a point of an obstacle, it's going to roll along the point of the obstacle and create a circular path or part of it until it can then take a straight line towards whatever its target is. That's the exact same issue that you're facing with the expanded geometry. But yeah, so expanded geometry is very popular to use with Navmeshes and in particular, because it's simplifies the runtime performance of the Navmesh, how the game can leverage for the agent any calculations, leveraging this information, treating the agent as a single point, and then being able to move around within each of the NavMesh polygons.
