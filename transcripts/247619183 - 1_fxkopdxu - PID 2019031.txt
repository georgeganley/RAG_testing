>> Hello. In this lecture we're going to introduce the concept of navigation meshes or NavMeshes for short. So this is a popular form of discretized space used in video games. And so we're going to look over the features of the NavMesh and compare it to other sorts of discretized spaces we've talked about previously. So first of all, think about the grid lattice and how it has a uniform structure and it has this implicit mapping to game world coordinates. So each cell of the grid lattice, you don't need to store any information about the game world directly as a part of the cell. The overall grid, which is an array or a matrix, we have where it is placed in the world according to the gridWorldCorner, and we know the cellWidth, and for any given cell we know the x and the y. And we potentially could also consider the overall dimensions of our array or matrix. But in terms of a mapping function, assuming that the x and y are out of balance, each cell we can just consider in terms of the x, y position as far as mapping to the world. So that would be starting from the gridWorldCorner plus the grid_x times the cellWidth and the grid_y times the cellWidth. So that'll give you an offset to a particular place in the world. So we can perform quantization and localization. So going back and forth between the two is pretty straightforward to do in terms of mapping functions. And so any individual cell, there's not a lot that we need in terms of storage. It's just a Boolean that we need, and then some fraction of this data, like the x and y, and the corner, and the width, and the grid dimensions perhaps. So demand is spread out across all the cells. So very efficient per cell. But we know that a grid lattice can be very dense and have a big impact on memory and also impact on search performance. But we might consider, instead of having a uniform structure, we can have a non-uniform structure. At that point, most likely we're going to need an explicit mapping to allow for this dynamic discretization that's going to be occurring. Meaning that each unit, so the equivalent of a cell in a grid lattice wherever this unit is, is going to have to store the information that tells us where it is in the game world. So for instance, using a polygon, we need to know where each of the vertices of the polygon are in the world coordinates. So comparing polygons to cells, the polygon is going to be more expensive to store than the grid lattice. But there is an advantage here in that, whereas the grid lattice we have this uniform resolution across the world, so even if you have a big open area, you're still going to have to cover the same area with the same number of cells per unit of distance in x or y, compared to a very detailed or complicated area. But when we have this non-uniform structure, we can scale the complexity. So a big open area, we can just have a huge polygon. And if it's a more complicated area, we can have more fine details. So the grid lattice might do a better job in really complicated areas. But on average across an entire environment, we can really get a huge payoff by having this ability to adapt. So this is demonstrating one of the motivations for the NavMesh. So instead of a square, we will have arbitrary shapes, so polygons that can maybe have different number of sides for instance. But maybe we don't want to allow too much freedom, because that would introduce all complications in terms of an algorithm. So we probably certainly want to exclude complex polygons that have self intersection and holes, and so on. And even concave polygons could be difficult when you start to consider the concavity that might appear and how you might fit together different polygons if we want to cover some space. But a convex polygon has a bunch of features that are nice and are computationally much easier to deal with. So our NavMesh will consist of convex polygons. So some of the reasons why this is desirable is, well, often is part of the discretization and localization steps, we will want to be able to consider whether points are inside of our polygon. And it can be very efficient, a straightforward implementation, not necessarily the best, but at least a good starting point, is that we can iterate through each edge of the polygon counterclockwise, and then testing if the candidate test point is to the left of the directed edge a, b, and just repeat that over and over. So a point that is in the polygon will be to the left of every single edge. And we can also perform efficient segment intersection or re-cast intersection test. And so similarly to the point test we can iterate through line segments and then perform a line intersection test, and also a point containment if the edge we're testing for is entirely contained within the polygon. You can check out the computational geometry lectures for more details, but hopefully that gives you a good intuition as to why convex polygons are desirable computationally. And they also have nice features for representing navigable space. If we're trying to support an agent that is inside of one of these polygons from a 2D perspective, like walking on a surface for instance, we don't want the agent to have to do a lot of work to move around in that space. And a convex polygon is going to allow for some pretty straightforward rules for what the agent can do. And that's because you can pick a point anywhere on or in the convex polygon, and from that point you can see with a direct line of sight any other point on or in the polygon. So that means the agent, wherever it is within the polygon, can walk in a straight line to anywhere else in the polygon. So that's a really nice feature. You don't want to have to do anything that is like obstacle avoidance or planning within that structure. The whole point of the NavMesh is to support path planning. So we want to build up from something that is very easy for the agent to work with. So that's something else that is good about using convex polygons. Now some implementations of NavMeshes might restrict things to say, only triangles which have even simpler tests, of course they're still convex polygons, but some of the computations can be easier and others may work exclusively with rectangular shapes or some limit to how many edges can be present. And so there's different pros and cons from selecting a limit for the specific convex geometry. We won't go into that, but at minimum, having a convex polygon is really fundamental to the NavMesh. So next step, we can think a bit about how this compares with the path network. So here is a scene that shows how we might have a path network defined that has different nodes with edges connecting. So this describes how an agent can walk through the environment to get to different locations. And similarly, we can have a NavMesh that does the same thing, and so you can see in both cases we have a graph structure. In the case of the NavMesh the nodes are entire convex polygons. The edges are the adjacencies with other polygons. So any common edge between two NavMesh polygons that defines an edge. But we also have this further benefit of an identified area that the agent can occupy. So we know that an agent can't really be on a path network. The agent occupies some area, it is not like a point. So it can't be perfectly at a node or on the line. It can only be centered on one of these locations. But in the case of the NavMesh, we have the structure to actually analyze area and know that the agent can be in a particular NavMesh, can move around within the NavMesh in many different positions and still be able to traverse from one NavMesh polygon to the next, performing path planning and maybe even refining or revising on a small-scale the movement along the NavMesh, which can be beneficial for avoiding obstacles, and that thing. So the polygons and their adjacency defines a graph, in fact, it's typical that you, as part of generating your NavMesh, will also generate something that is essentially a path network that is part of the NavMesh structure. So for instance, you might pick the centroid of each convex NavMesh polygon to define a node. And then of course you also have the edges connecting each of these nodes that you can determine through analyzing your NavMesh adjacency. So that information is useful for supporting the search and also having a specific path that you want the agent to follow that actually involves specific world positions that are easy for a character or an agent movement, strategy like a steering behavior to follow a path. So that's the basic concept of a NavMesh. So next up we will look into the specifics of generating a NavMesh. So in terms of analyzing a world scene and determining where to place polygons, how to figure out which polygons are adjacent, and so on.
