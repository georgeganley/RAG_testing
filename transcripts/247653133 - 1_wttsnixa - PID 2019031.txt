>> Hello. In this lecture, we're going to look at terrain generation as an application of procedural content generation. So with terrain generation, we can work with what we know of real-world terrain in terms of the dynamic natural processes that have formed the terrain that we're familiar with. And that we have some understanding of various scientific field that have studied, say geology and the changes to terrain over time related to tectonic plate movements, volcanoes. The way that rock and soil can be manipulated through these processes and how the different physical properties lead to different types of structures. And so this can be with emergent physics-based simulation or through some model that has been fitted to observed data. Similarly, we can look at the effects of climate, which includes wind, the erosion, and movement of materials like soil. Same with water, how it can carve through terrain surfaces, glacier erosion, there's also a temperature driven changes. So there's lots of knowledge and models that can be leveraged in terms of terrain generation. That said, the potential algorithms that we might use could get rather complicated and maybe beyond what we want to use in terms of video game terrain generation. So we probably don't want to build a world completely from scratch and based entirely on physically simulated processes. Instead, what we might do is start with some more abstract process that roughly models features that are maybe similar to what we see in the real-world and then once we get to that baseline, we could then have some simplified approaches to applying weathering type processes. So that was sort of give us the improvement in efficiency, we can more quickly get to a starting point rather than building from scratch and then we can add to the surface of what's created. Many fewer steps of any weathering simulation, but still have it look like a world that was fully the result of those natural processes that we're familiar with. So to get that base terrain that we're going to start with, we need some way to define these basic shapes. So a good place to start would be a random noise source like a random number generator. The problem though, is that your typical random number generator with uniform distribution, you're going to have too many frequencies, especially high frequencies and they're all of the frequencies are going to be at the same magnitude. So you're just going to see static or just lots of spikes and not any of the natural fractal structure that you're familiar with in natural settings. So it would really be nice if we had some other way to define our noise and so a popular approach is Perlin noise. So we can see here uniform random noise that just like white noise static and then we have Perlin noise on the right. And so Perlin noise, you can see that there is higher frequency noise present if you look closely, but the magnitude difference is much smaller relative to these lower frequency features. So you can see rolling hills or puffs of smoke from this perspective in this image and there's texture to them, those higher frequency details, but they're not so extreme as you see with the white noise. So this looks much more natural, you can probably think of real-world things you've seen that looks similar to this. And so if we can make noise in this fashion, that it is going to be a way we can get much more realistic looking features. So actually, with a Perlin noise, it's typically layer to get the different frequency ranges. So by itself, you have a gradient noise this based on a lattice. >> And minimum will have a 2D lattice, but you can go to higher dimensions as well. So it's pretty common to go to three dimensions, for instance, so that would work well with voxels. For terrain that this height based, 2D is fine for that. So I just said a high level, the way Perlin noise is defined. Again, you have a uniform grid, and then at each point in the grid structure, there is a seated random orientation and magnitude within some range. So this controls a weighting effect that is used to determine intensity at the sample positions that are in-between these control points. And so a neighborhood, in any given pixel is found relative to these neighboring control points that are aligned to this lattice and a weighted determination of that given pixels value is found. So the end result is that there is a gradient calculated because of the interpolation between the different control points. So if a pixel is really close to one control point, then it'll be primarily influenced by that one. And since these are all randomly assigned, you get this nice gradient. And so the way the Perlin noise is typically used, is you don't just use the gradient one time, you actually layer it, and the different layers can be offset. And it's also generally used in a tiled fashion. So you can determine the control points, and the lattice can be set in such a way that if you align top edge to bottom edge of copy of itself, that it fits perfectly together, so that the interpolated gradient smoothly transitions as it wraps around top to bottom, left to right, right to left, and so on. So this makes it really easy to work with, and it works especially well if you have a situation where you want to tile, so maybe tiling a terrain, or if you can use Perlin noise for generating textures as well for texture mapping, and it can work well for that situation too. So once you have your ability to calculate the Perlin noise, again, you can layer it so that you have different frequency ranges that contribute to say that a height map. So you have some lower frequencies, which it would appear It's like large features such as mountains or hills. And then you could have rather a higher resolution layered on top, but with a limited magnitude. So you wouldn't have the next layer applied on top to have the same magnitude as the layer that was lower frequency. So when you do that, what you end up with is it looks like you have, say, large mountains or hills with smaller features that are layered over top. And this is normally done as octave, so they're multiples of one another. And it can give very compelling features. And there's nothing that forces you to go strictly with octaves. In fact, in the starter project that's used for the procedural content generation homework in the class, there's no restriction in how you setup each of your layers. So you can pick an arbitrary scale for multiple layers just as you please, and you can play around with different offsets for each of the layers. And then select, give some freedom to just refine and try to get the desired combination. [NOISE] But with Perlin noise it does have a predefined and limited range and therefore it's going to repeat. But even with a repeating, it's often difficult for someone to notice because of the way that the multiple layers can interact, and then you can have other types of terrain generation features as well. So it can be awhile before any obvious repeating is noticed. But you might notice that there's common features that are repeated, they're not necessarily exactly the same. And so the fact that it can tile seamlessly is especially useful. So once we have this ability to layer Perlin noise, we might think about ways to have more flexibility and more control over this process, and we might even introduce additional capabilities. And so you can make some pretty elaborate terrain generation rules, just by working with Perlin noise. And so we have the homework project in the class working with procedural content generation. It supports the ability for the user to create a tree structure, and you could even have a directed acyclic graph with branches that merged back, if we had a graph editor that supported. So the current project is just using the Scene View in Unity rather than a full-blown graph editor. But there's no reason why it couldn't be with a directed acyclic graph, which would open up a few additional possibilities. It might even be possible to leverage unities, shader graph structure. And that's one thing that I'm interested in looking at implementing is saying if I can move the tool to use that and you additionally gain the benefit of running the terrain generation largely on the GPU, so that you can get some performance improvements from doing so. But the general idea is that you can create this graph structure. Each of the nodes have responsibilities that allow the user to declaratively define rules for terrain generation. So one important aspect of the nodes of the graph is to generate noise through some constraints, such as the scale level or the zoom level of the Perlin noise, as well as offsets. There may also be remapping functions that take the generated heights from the Perlin noise and just run them through some function that remaps them. You could even use more elaborate mapping, such as a convolution. So in the case of your typical terrain, you have a 2D height map, and so not only can you remap a pixel based on its previous value, but you can also remap a pixel based on its neighbors. And so a convolution is a process where you can look at the neighborhood of a single height value and then change it based on the heights of other height map pixels around it. And so you could get some interesting effects by doing that. I've played around a little bit with doing that, but I haven't fully integrated that in. But this is something that could easily be applied if you are running like Unity shader graph or major own GPU based implementation, the convolutions could be pretty efficient and would open up some other possibilities for terrain generation. So that's just generating the noise, but there's also the most powerful capability with this approach is by creating these graph structures with these nodes, is that you can combine the noise in different ways. It doesn't always have to be additive. It can be subtraction or multiplication and other approaches, and you might even have different nodes interpret the parent node differently. So a node with multiple children, or each node could interpret what base noise provided by the parent interpret that differently and combine differently. So this opens up lots of possibilities for authorship. >> In terms of the approach that I use for the homework, I haven't even fully explored everything or figured out everything that's possible. So I guess you can start to think of it as a pro and a con of this approach. It does make a pretty powerful tool in terms of flexibility, but it can also be at times overwhelming and difficult to understand or to develop an intuition in terms of authoring, especially if you have something in mind to make, rather than just randomly exploring and seeing what interesting things you can make. If you go on with a specific plan, it's sometimes difficult to pull this off, but overall it's fairly computationally efficient approach, simple approach. And with tile and Perlin noise, you can make a nearly infinite terrain that tiles with a terrain system. So if this was properly and fully tied into unities terrain system, tiles could be just dynamically generated as the player, let's say, walks near the edge of terrain square. Then the next square in the grid could be requested, and the terrain generated based on whatever the offsets are as the tiling occurs. So this could support runtime procedural content generation. Now, the next thing that you can do once you have this terrain is that you can consider applying the simulated natural processes like we discussed previously. So this would involve perhaps multiple iterations of these geological and weathering effects that would be applied to the base terrain. So once you generate your rule-based terrain with a hierarchical rules about combining Perlin noise, you might want to add some effects that are related to, say, fault lines or the way water runs over a surface and it erodes over time. So depending on what your needs are for your procedural content generation, you might apply some or all of these different approaches that we will look at it with a high level here shortly. But doing this, it can give a more natural end result, but it comes at a cost of additional computation. So this might impact, say, runtime procedural content generation, and that could possibly be something that would have a negative impact on your game and maybe would not be worth the trade-off it, it might be, and it might also depend on whether you're creating your terrain at design time and then storing the entire thing or generating it. But first we could consider faults. So this is really a pretty simple approach. You simply identify a fault line, and then anything on one side of the fault line is raised or lowered, and then vice versa on the other side [NOISE]. And it can be a fairly small amount, often this will be done in conjunction with other effects that would be running. You might apply the faults many times over many simulation steps. So this particular figure shows after application of hundreds of faults, and not mixed in with other approaches, such as the effects of water, for instance. But this might work well especially integrate with other approaches. Then there's thermal erosion, this is based on the observation that common types of granular substrate like a soil or sand, will tend to bunch up in particular patterns with certain slopes. So this is just something that happens incrementally over time. So you can run this multiple steps and it would require identifying where in your terrain do you have these common substrates? So if you don't have volumetric data, a simple approach to do is to simply identify an altitude band. So this would mean you're looking for a range of heights. So maybe you would avoid really tall structures because that would suggest it's made out of hard stone so you wouldn't apply the process there, and maybe you wouldn't apply it at the lowest levels, but maybe a certain band that you, say, would be maybe a little above sea level, but not the height of mountains and then could apply this. If you have biomes identified, you might have different types of soil defined. Like for arid regions, you would have a different soil type, probably sand, but if you have soil identified in a biome that has lots of foliage, plants of some sort, you would expect maybe the root system [NOISE] to restrict how quickly this thermal erosion process would occur, and so you could adjust accordingly if you're modeling that information. [NOISE] Hydraulic erosion is perhaps one of the most compelling weathering effects that we might apply, especially given that the rule-based approach for combining Perlin noise is going to have limited ability to allow an author to create the detail and structure that you can get from hydraulic erosion simulation. Unfortunately, this is one of the more expensive weathering effects computationally that we might want to apply. [NOISE] It involves breaking the world up into small pieces and considering small amounts of water being placed around the terrain and modeling how the water moves. So this is a finite element method approach, and it involves iterative simulation. So we have to place the water in the environment, this would be by some rainfall modeling, and then the water flow needs to be calculated. So water will be affected by gravity. It will tend to accumulate in different cells and then a voxel structure. And then, based on the accumulation of the water, we'll have some simulation rules that approximate the effects of the water movement picking up soil. So that would be taking away from the height map, and then we would need to track the soil that's being moved as part of these finite elements and then being dropped later as, say, the water changes velocity or reaches a lower energy state, it would carry the soil from high ground to low ground or move it along the direction that it's flowing. And as you can imagine, this can get pretty expensive computationally, and it's also something where you benefit from many iterations of it. So while the visual end result is quite compelling, it might not be feasible for some types of terrain generation. So for instance, if you are generating an infinite or near infinite terrain and doing so at runtime based on procedural content generation rules, you may or may not be able to run this simultaneously during gameplay without an interruption. [NOISE] >> So another approach that can be used is altitude filtering. Basically, this just means modifying terrain values based on existing heights that are present. And so there's actually a lot of overlap with the capabilities of the hierarchical terrain rules or the directed acyclic graph on the nodes. You can already do a lot of what's proposed here. So this is actually from Millington's Game AI book. And so he goes through a number of different examples showing how you can apply different effects to a base like a starting terrain, so perhaps amplifying the relative distances between different terrain height levels. So this can, for instance, bring up plateaus out of a largely flat area, like maybe you originally started with only just some subtle differences in height but then you can exaggerate certain features, and there's a few other examples. And so a few of those could easily be represented just as mapping functions. Some are more complicated and might require rules that are convolution base so that you can analyze neighbors, but just basic limiting modifications of terrain based on ranges of height values. It is something that is easy to include in the terrain rules engine approach. So there are other ways we might consider making terrain as well. So we've really focused mostly on rules-based approaches so far. So in fact, there's also the possibility of using cellular automaton. And this is where we have little simple rules applied to individual cells. So we might have a discretized world built into a grid structure, and then we have rules about how the information in each of the cells interacts with its neighbors. And so we have a kernel or a certain set of rules that we apply uniformly across all pixels. The only difference in result is based on the neighborhood of each of the grid cells. And then, of course, the rule-based approach which we're familiar with from the discussion up to this point and also from the homework project in the class working with terrain. So the cellular automaton approach is interesting because it's so simple in terms of execution. You just iterate through all the discretized cells that define your terrain. So it could be a height map, it could be voxels. Or most commonly though, the cellular approaches are 2D, so building things more like a maze-type structures. But the advantage is that if you find something that works, and that's really the key here is coming up with the rules that give you something interesting result-wise, if you can find that, then it's very concise definition and can give interesting results. So you're probably familiar with cellular automaton. You've likely seen Conway's Game of Life and perhaps even implemented this in an intro computer science class. In a computer science education, a popular project. It's basically, you write or you implement a 2D array and the 2D array can either have cells that have a living value in it or dead. So it's just like on or off, basically. And then you have rules about the neighborhood of the cell. And so the idea is through every timestamp you iterate through all cells and you evaluate the rules. And so the rules are based on the neighboring cells. So any live cell with fewer than two live neighbors dies, and the idea here is this is caused by underpopulation. Any live cell with two or three live neighbors lives on to the next generation. So it's like the ideal state. Any live cell with more than three live neighbors dies, and that's overpopulation rule. And then any dead cell with exactly three live neighbors becomes a live cell, and that's the reproduction rule. So the rules themselves are very simple. It's very easy to write code to evaluate these, so we can quickly iterate over an array, apply the rules to determine what the new value is in the next time step, so you can use similar approaches. For terrain generation, you come up with rules that give interesting results. You come up with some configuration to start with some seeding process. So you populate your grid structure with values and then you run the simulation. Basically, you're looking for a point of stability where initially you get a lot of changes, the structure grows creating your terrain, and then it stabilizes to the point where there's just a minimum level of change. So this is easy to implement. You get very complex behavior from just a small set of rules. It can work well for making your terrain structures for your game, but in terms of downside, there's a lot of guesswork. It's hard to engineer something using cellular automaton because of the fact that it is an emergent outcome. So when you have this potential for emergent outcome, the only way to find out what it does is to simulate it, so there's lots of trial and error. Also, it can be hard to debug. So if you have different initial configurations as part of your game, you might miss some initial configuration or an edge case like maybe you have one environment crossover into another, and so there's an interaction there. And if you haven't tested or planned for that or have some rare combination, there might be some weird outcome and strange resulting terrain or perhaps a broken terrain, so it can be a bit dangerous. And it's hard to constrain as well because the ideal way to manipulate the behavior of cellular automaton is to simply adjust the rules of the system. But doing so can have rather profound effects on the overall result, so you can't really add special case logic to deal with one particular undesired output. So you might instead try to add like a watchdog process that oversees and monitors what the cellular automaton is generating and then try to restrict or block, and so that adds a lot of complexity rather quickly if you're trying to do so. From what I've seen, at least cellular automaton approaches, while they're interesting, it's most commonly applied in simpler 2D scenarios, more like building mazes. >> More difficult to scale to larger, and more complicated scenarios like 3D type of scenarios. That's not say, it's not possible though. So next step, let's consider how to make Minecraft. And so with the game Minecraft, it's unique, at least compared to what we've looked at so far, we've focused on height maps. Because Minecraft has truly 3D terrain, represented by voxels. So it has a terrain that's generated by noise. But this noise gives the 3D structure to the terrain so that there's more to it than what a heightmap provides, even though the end result in a game is a 3D, terrain, there is really quite limited because you can't have, say, overhangs or tunnels. And Minecraft is all about caves and tunnels. So we have the noise source and it's actually, it turns out is 3D Perlin noise. It's also has a rule-based structure. We can think of it as different agent implementations that have special jobs that they have to perform. So it's specializations in terms of the procedural content generation and terrain creation. A bit similar to the way we've so far-seeing with the height map-based approach of having special rules for different combinations of noise, and then especially also the weathering of the terrain. So we have similar approach with Minecraft. So there's agents that deal with generating the terrain, converting terrain types figuring out where soil is in stone. Each of these agents get different opportunities. There's this really nice video on YouTube. This was developed by AntVenom on his channel. Of course, you can go check out his channel, maybe check out his other videos as well. I'm going to show here his little short video he did about Minecraft, and how it is actually generated. So there's multiple stages. And at each of these stages we can think of it as different dedicated agents that do these creation steps to create the Minecraft terrain. So I'm going to let this play and you can check it out. >> Today I want to do something pretty unique in today's video, I want to visually show you how Minecraft generates its terrain using four separate mods, each of which show you a different phase of Minecraft world generation, starting with the stone only noise map and working our way to the foliage-filled world that we ultimately see with Minecraft. Unless you've given it a decent amount of thought, you might not be aware that the game actually generates one thing at a time, but very, very quickly. And after spending weeks of trying to figure out how to make the mods required for this video, I caved and asked a friend of the channel Lucavon to help me out on this quest. And he had all four mods done within just a few hours. What a boss. So with all of the pre-work done, let's go ahead and let's get right into it. So if you've ever heard me use the term 3D Perlin noise in previous videos that I'll have linked above, then what you're about to see on screen is a visual representation of it in action when Minecraft generates its terrain, it first starts out with a noise map, which forms the shape of all of the terrain, including hills, valleys, oceans, and rivers within Minecraft, this comes in the shape of a world made entirely of stone and water. At this point, no caves of any kind have been generated. One other thing that has been generated, however, are all of the oceans and rivers which generate on any vacant blocks with a y-value of 64 or less. As you can see, this forms the foundation for Minecraft terrain. Beyond this point, more terrain elements will begin to generate. After the stone and water noise map are generated, the primary surface of the world itself is formed. And while they originally thought that blocks like dirt, grass, and sand would generate on top of the top layers of the stone noise map. They actually overwrite the stone itself, but without any trees, caves, or foliage. However, caves aren't far behind in the code, actually generating immediately after the surface of the world completely forms. You might notice at this point, however, that ores like traditional ores along with direct andesite and granite don't generate just yet. And that makes sense. If the ore is generated before caves did, that could potentially take up a lot more computer power than would be necessary. But as you might expect, however, all ores generate immediately after the cave systems do. We now have the overall world without any foliage, and we have cave systems with all of the underlying ores. After all of these terrain elements are formed, Minecraft adds all of the world's decorations. This includes things like trees, tall grass, flowers, and as well structures like the pyramids, jungle temples, ocean monuments, and everything in between. At this point we are now playing the full and complete version of Minecraft. Obviously, I don't need to provide a mod for this stage of world generation as everything is now completely done, whoever in the description below, I have included the four mod that Lucavone has created for this video. The mod that causes only the stone and water noise map to form, the mod that only has the surface with no foliage or caves at all. The mod that has caves but no ores. And finally, the mod that has all ores but no overworld foliage. Beyond that is Minecraft release version 1.12. While I do plan on making more breaking Minecraft videos, as soon as I come up with some really solid ideas, let me know in the comments section down below what you guys thought of this kind of video, since it is much different from the majority of the videos that I've been doing. And if you did enjoy this video, then please consider leaving a like on it because it would really help out myself, the channel and the video quite a lot. So I hope you all enjoyed. My name is AntVenom and I bid you all farewell. Thanks so much for watching. >> So I think that's an interesting look into how Minecraft works. One of the most popular games with procedural content generation. So of course in the case of Minecraft needs to be very efficient implementation of their generation algorithm so that it doesn't make the player wait forever for the initial creation. And then as the player moves past those initial boundaries to not have a big impact on the game. So overall, it's really pretty simple. It avoids some of the issues that might otherwise want some of the weathering type effects are not generated. Instead, there's more abstract processing that takes place. But it still results in compelling gameplay, unique environments, and is been a very popular product, and entertaining for a lot of people. So to close out discussion of terrain generation for procedural content generation. One really important step that we haven't discussed yet is the issue of placing terrain features. So once you've generated a terrain, you need to add some interesting things so that you don't just have like a barren moonscape. Ideally, you would want to have objects such as trees and bushes and rocks or other decorations that would be placed. And so that's certainly a critical step. And it merits its own lecture topic that we will go into in the next lecture. So we'll discuss ways of placing objects that can work well in a terrain. And of course, we want to be able to do this efficiently. So we will stop there.
