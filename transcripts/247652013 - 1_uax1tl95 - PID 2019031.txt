>> Hello. In this lecture we're going to look at random number generation and it's importance for procedural content generation. When we're generating our procedural content, we need some sort of information source. This is going to help us to defined parameters in models or algorithms that actually do the work of generating content. There's usually a very large space that is defined by an algorithm. There's not like one path to generate what we want. There are configurable parameters. And these parameters could have continuous ranges or may be integer values. But there is a configuration that we might set initially, or we might have to constantly provide new, new control values. For instance, if we have a Bezier curve that we're using to define a road or some other type of path. We might have some initial segment. One piece of a curve. And soe would need some configuration of that and so there's near infinite number of possibilities there setting the anchor points and the tangent control points for one segment and then if we wanted to continue the path, we'd add another segment which would have an additional control point. And depending on how you're controlling the tangent, you might be adding two new control points that may or may not be constrained in some way depending on if you're keeping parallel tangents across control points. But the important thing here is that there's this configurability to this particular model. So in this case, our curves, but we might have some other type of procedural content, like terrain or textures, or other types of content we might want to generate, maybe music or sound effects. And all of these will generally have a lot of possibilities for parameters. So the random number generation, if we can generate values, then we can plug them into these models and that will provide us then with the output content that we desire. Now there's some challenges here. One is that in many computer science applications, especially in recent years, with the importance of cryptography and making sure that the Internet applications are secure and cannot be exploited. There are a lot of random number generators that strive to have something approaching true random values. So while there might be an algorithm involved, you might find, say, processors that have some hardware support, that part at least partially provide some values that are maybe based on the laws of physics and being able to extract certain characteristics from measurements, say, of the way heat spreads between different materials. Maybe monitoring background radiation. Possibly you have measurements from the user, like their mouse movements or other types of interactions with a device. And so from those sources, there might be some information that's been passed onto a random number generator algorithm. And so that natural random information is mixed in with an algorithm. And so that's very useful when you are concerned about things like security and making sure that hackers can't break into your computer. But this is not necessarily something that is desirable in terms of an information source for procedural content generation. Generally, when you're talking about procedural content, you want to be able to re-create that content anytime you need it. And so we would like to have the ability to create a random sequence and then be able to recreate that again later and not have to store the entire sequence like on your hard drive. Instead, we'd like to just store the starting value and from that starting value, generate everything needed to say control our Bezier curves or our terrain generation or whatever other content we might want. If we do not have this ability to restart our random number generator and get the same sequence, then we would not be able to recreate the content. So many of the procedural content generation applications that we've talked about before, especially say, being able to minimize storage requirements, we would lose out on that to a large degree if we did not have the possibility of random number generation that can be defined just from a starting value and then work from that. Now in terms of what you get from the random number generator, generally what you want is a uniform distribution. So by that I mean that all values are equally likely to occur. And we will generally see two flavors of the random number generator. So you may have continuous floating point values. This is often within a range, say, typically this is from 0-1. And of course you can just multiply this by your desire range and you calculate any range you want, starting from that 0-1 normalized scale. Some APIs will let you begin and end values and do all the work for you. And there's also discrete versions. Many APIs provide both. So you can generate integer values within a range and you specify the start and the end. And they vary depending on if it's inclusive or exclusive values in the range. But once you tell the random number generator what you want, the value you get back is uniformly distributed within that range. So any possible value within that range is equally likely to occur. So this is a good starting point, even if you do need other distributions of data. They're generally pretty easy to calculate by starting with the uniform distribution and then plugging that into an equation and then say you can get a Gaussian distribution or maybe a Poisson. Though, the computational costs will vary depending on what the nature of the particular distribution that you're generating is. >> So back to the topic of this repeatability of our random number generating algorithm or rather a pseudorandom number generator. So we call it pseudorandom because it's not actually random, it just has the appearance of being random. If you say analyze the values that are returned in a sequence so you can analyze them and you can see that they're uniformly distributed and that they're different, there's no detectable patterns in the values. So they have nice properties in terms of how these random values are spread out. So if our particular algorithm can use a seed, meaning a starting configuration value, this is called a mixing function. And the reason it's called a mixing function is that the bits of the seed, they all have an influence in the bits of the generated pseudorandom number. So that means if you, say, had two seeds and they were only different by a single bit in the same position, then the same pseudorandom algorithm will generate very different values that are potentially different in all the positions of the output value. So if you seed the same algorithm with the same seed value, then you get the same result. And if you keep calling the algorithm with the updated value or the updated seed or internal state, if that's maintained, then you get back the same sequence of values. So mixing function is defined by this process where we start with a seed and when we ask the pseudorandom number generator to update, a new seed is generated along with the value that's requested. And so this value would be used in the application. The seed would be maintained perhaps internally to the random number generator API or it might be the responsibility of the developer to track this seed somehow maybe in an object and preserve a reference to that object and then call it anytime that another value is needed and then that seed will be updated as necessary. So again, the fact that we have this seed value with the mixing function means that we can recreate the sequence of random values that we need. So we might store this in our game data, we can initialize our algorithm with the seed, and then we can make requests to generate as needed one value after another, and we're going to be guaranteed to get that same sequence. There's a challenge to this. So while we will be able to get this same sequence of values, we have to be very careful when we're developing procedural content generation solutions that we're always making the exact same number of calls to the random number generator that we're always putting the values into the right place in the procedural content generation algorithms, the correct coefficients or parameters, and we have to watch out for contention. There are often multiple systems or subsystems within a game that all contribute to procedural content generation. So you might have algorithms that deal with generating terrain, you might have algorithms that deal with generating the clouds or other features of the game. And as the game evolves, as the game is developed, you can have some change in the content change the order in which the random number generator is called. And so that is something that you have to be very careful about, is that you might, say, work with a particular concept level, like you get some initial procedural content generated. The mountains are just where you want them, the canyons and other features are exactly perfect for what you want and you start to build up other procedural content around that. And then if you're not careful, you end up losing the creation that you had before. And so that can be certainly frustrating. And you also need to watch out, not just for the evolving code-based causing changes, but you can have non-deterministic effects as well. So for instance, if you're not careful, you can end up with a frame rate dependency. And of course if the frame rate varies, then that might change the nature of the way that the random number generator is getting called, making these requests to generate content. And so you can just end up with a completely different experience every time the game is played if you end up with a frame rate dependency. You can also accidentally have dependencies on external events that likely would be triggered by actions of the human player. So as the player is deciding to move around in different ways, they might trigger content to say be generated incrementally. And you have to be very careful in those scenarios. You might trigger the content in a branching nature where you can get different outcomes in different ways. And if your intent is to always create the same level every time, then you might break that. >> Break that end up with different results every time the player or different players play the game. Here is a brief look at what Unity provides in terms of their random number generator. So their solution is interesting because they have a one-way direction to get the seed into the game but they actually maintain state with more data than a single seed. You can initialize the random number generator with a knit state and pass in an integer initial seed. But once the random number generator is initialized internally, it uses a number of different values beyond just 32 bits. So there's more bits than 32 to maintain state. So you cannot get a seed back out for instance. So you can initialize with a seed, but the only thing you can get out is what they call state. And so the state is that collection of more than 32 bits and it's not accessible, but it is serializable. So that means that you can preserve the state. Perhaps save it to a saved game and then get it back and then including re-initialize with that state. So that's done. You can set the static member variable, class variable, random.state. You can set to a preserved or serialized state. And then of course, you can query for new random values which update the state every time it's called. So typically that's going to be random.range and you can use integers or floats. And so the fact that you can initialize with a seed and also be able to save and read the state, makes this a good solution for procedural content generation. And furthermore, you can run into an issue where you want to isolate your random number generation between your different subsystems. So the Unity solution happens to work well for that because you can maintain these separate state values. As you switch between subsystems every time there's a context switch, you can just set the state to a preserved value. So each subsystem maintains its own state value, so when the context switches to a particular subsystem it would set the random.state class variable to its state. It would make its calls to random range or any of the other output methods that can be called. And then when it's done and ready to context switch out, then it can save its state. So it can always come back to right where it was before. And so this works well in other APIs, work similarly in other game engines, and general purpose programming libraries that you might find will often have something similar to what we just looked at. The general approach is you have a tree structure to this. So you might have a root level game manager that is seeded with a particular value. And then each subsystem refers to the game manager to get their own initial state. And so everything branches out from that route. And you might have sub-systems of sub-systems with particularly complicated solutions. And so each one just needs to store their state value, make sure that they load it when it's their turn to degenerate, and then save before their turn is over. Now, if you are using a random number generator provided to you, you need to be cautious because there's potential for there to be differences between say, platforms. So you might have different implementations, and I know JavaScript is one where you don't know what you're getting necessarily to meet the JavaScript standard. There, I think, are at least a couple of different valid solutions. So that would mean you'd have platform differences if you're trying to generate, let's say, a procedurally generated level in like a web game. So you probably would be better off considering just using your own implementation where you have full control of the code and can maintain the portability yourself if you're deploying to multiple platforms. And so that is actually a recommendation. In the Millington game AI book, so he often, in the games he works on, will use his own portable code with an implementation that he can fully trust. Last thing I want to mention about random number generation is the quality of random number generator. So I started off by telling you that the random number generator is a source of information that we're going to plug into a parameter space of algorithms or models that we have for say, generating terrain or paths or the various possible things we might want to create. It's important to realize that random number generation is often too noisy to use directly. Like here we see what would happen. This is from Millington's book where he shares what would happen if you just directly use a random number generator for each height map level in a height map for terrain. So if you just go from walk-through to the x and y positions with like a nested for-loop. And then for each pixel, keep calling the random number generator. You can certainly do that and what you'll get will look like carpet in terms of heights or if you just looked at a raster image, it looks like static. And that doesn't make for very compelling content, it's got way too much high-frequency noise. We would prefer to have lower frequency that's more in line with natural features. And this is a common problem that you run into with a path if you try to generate, say, a random x and z position to define a 2D path. It's going to just be jumping all over the place even if you constrain the ranges so each segment length is only so long. You're just going to have what looks like spaghetti if you don't further constrain it. And so using something like Cubic Bezier curves, it provides a nice constraint and allows you to have smooth natural looking like roads, for instance. So it's really important that you're identifying an appropriate model or algorithm that you're going to be plugging your random number generation into. And then that's really the key to getting quality content for procedural content generation.
