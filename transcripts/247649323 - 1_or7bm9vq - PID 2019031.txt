>> Hello. In this lecture we're going to explore the topic of fuzzy logic. So let's start off by considering this scenario of making a grilled cheese sandwich. So we have basically a recipe here of how to make our grilled cheese. So we've got two slices of bread, a description of slicing the bread medium thick. Turning on the heat to a high setting, and then grilling the bread until golden brown and so on. Now think about this recipe in terms of you following the instructions. And then in terms of how to automate this with computer technology too decide like, how thick to slice the bread or how hot to heat up the griddle. So that suddenly becomes a lot more challenging. When you think about, well, how would you make a computer recognize these very subjective objectives for the different steps of making the grilled cheese sandwich. So this comes up a lot, especially when humans are involved. And so we have this non-numeric linguistic expression. So a lot of subjectivity and vagueness. There are flexible interpretations like these words may mean different things to different people. But I think probably most people could follow that recipe. And while each might get slightly different grilled cheese sandwich, that all probably end up with something that's edible. So it's really a challenge from the perspective of conventional logic and applying logic and decision-making to a computer. So this is where fuzzy logic comes in. We are going to embrace this linguistic characteristic of describing decisions or processes. And we will be able to work with these linguistic ways of defining the states of different objects and be able to maybe interpolate between different strategies if you're in the middle and gray area, but between different possibilities, that's something else that the physiologic can deal with. And to do so, we're going to be working with rather than absolute, like black and white, true or false. Instead we'll have this gradient between maybe two extremes in the case of a Boolean logic. So if we think about decision-making that we've seen so far, like decision trees, rule-based systems, finite state machines. Those all work with these very distinct transitions from selecting one rule or another or transitioning from one state in a finite state machine to another. And if the behaviors that the agent exhibits according to those states are distinct, then we're going to have this very abrupt transitions. So as soon as the transition completes in the finite state machine will immediately have entirely new behavior. And so that switch can be very unnatural. And it might be a bit extreme given the change in world state, we might prefer to have something more gradual in terms of switching from one state to the next for instance. So fuzzy logic is something that, has been popular over the years, but is largely dismissed by the academic community and AI, that being largely because fuzzy logic is not motivated by probabilities or observed statistical pattern of the, say, in the case of a game, it would be like, what's the likelihood of certain things to happen? And a lot of what fuzzy logic does have a bit of a feel of being probability-based, but It's actually not a probability is more of just a way to define different behaviors or strategies, which we'll see as we get into. So physiologic has been something's really pretty popular in the game industry for decision-making. But you will often see it frowned upon in terms of academia. So with fuzzy logic, we have modeling of imprecise concepts and modelling of imprecise dependencies between these concepts. So it can be thought of as a superset of classical logic. But the end result is that we will have this fuzzy characteristic, as we will see. So will be introducing this concept of degree of membership. And this is membership at say, some particular variable to have a certain state. So like temperature could be cold or warm or hot, rather than saying that this is all yes, or all no. It's either hotter, it's not. We could say, it's a little bit hot for instance, this degree of membership is a way of saying how much is that the case or true. So it's not going to be like a binary yes or no. And so we will also be defining fuzzy sets and fuzzy rules. Again, this is not going to be probability. [NOISE] >> So we can consider a thermostat example following along with this use of temperature. And so we're going to start with what we're going to call crisp values. And so we have some measurements. In this case, it is a temperature in degrees Fahrenheit. This could also be other measurements, maybe measurements like a video game. It could be say a distance or an angle. So there's all sorts of different ways we can define what our crisp values are. And it doesn't have to be a float. It could be a Boolean or categories like an enumeration. It could be integer values. So there's lots of possibilities for what we will use for our crisp values. You can see here we have what we will later be calling membership functions. On the figure here, we've got a graph of temperature and then overlaid with the temperature scale, you see a trapezoidal shapes for cold, warm, and hot. So these are our membership functions. So we can think of this process of taking a crisp value and converting it to a membership in a fuzzy state. So depending on where the temperature is on the graph there, we can look above for instance, and say, well, it could either be a little bit warm or a little bit cold perhaps in the area where the two overlap. We might have rules that work off of the conversion of the crisp values into those fuzzy input states. So here's a set of different rules we might have for thermostat control. If the temperature is very cold, then fan speed is stopped. If temperature is cold then fan speed is slow and so on. So we have these different fan speeds that result from different temperatures. Now, these rules, if you just read them as they are, they do have this subjective, very vague presentation. I'm sure you can look at them and understand. If we put a person in charge of the fan speed just by feeling the temperature and saying, well, it's cold or warm or hot that subjective response. You'd get appropriate behavior for the fan with the manual control. To make this work with a computer, that's a lot more challenging because now we have to define what cold and warm, and hot are within some ranges. And the rules as written don't suggest what to do if we have values that fall in-between. Well, I can't decide if it's cold or warm. So what do we do in that intermediate stage? You as a computer scientist probably can think of ways how you could implement that in code but then you're getting to the point where you're moving away from these rules and then say doing some linear interpolation between different values and so the result is going to be code that is much more complicated than the easy to read rules that are presented here. So let's consider some different use cases at a high level when you might want to use fuzzy logic. So it can be a more direct way to represent expertise because if you think about the typical expert in any field, they're probably not going to be computer scientists and not think in terms of procedural logic. Instead, they're going to define their processes in a linguistic form. They'll be much more declarative. And if you were to say, consult with an expert to help you design an expert system, then there's going to be a challenge because you're going to have to translate their understanding and way of describing their domain, translate that into a code. But with fuzzy logic, we have this potential to maintain the expertise in a form that the expert would still understand it. Even if you are writing the rules we were looking at before, if you're writing those in code, you might build to still maintain some readability. We could even go further and say, build a declarative scripting language that works in the fuzzy logic framework. And maybe we could even have non-computer scientist build their own fuzzy logic solutions. So we have this ability to capture expertise and if we consider other possibilities for how to replicate expertise, one might be use, say a neural net and train it. We could observe the expert making lots and lots of decisions. And then with enough observation and enough training, we could perhaps replicate the expert. But this is really changing the requirements for the problem, for building the solution. Now we have to budget to collect all this data from the expert. It's not necessarily going to be possible. You might only be able to talk with an expert for a brief amount of time, collect some information that would be basically the linguistic form of their own set of rules for solving a problem. While something like a neural net may be more grounded in understanding probabilities, statistical likelihood of different scenarios occurring. Fuzzy logic, it has this ability to very quickly design behaviors in a system that can transition smoothly from one strategy to the next. So you might select to use fuzzy logic in a video game because you're not really looking for an optimal solution. That is something that's probably likely most agents in a game or other applications of AI in video game technology, you're not looking for optimality. You're instead looking to create entertaining behaviors or other AI-driven solutions. Just because fuzzy logic isn't grounded in theory that will allow you to target this sort of optimality, doesn't mean that it can't serve a purpose. And so we can avoid the resources and the time. The overall expense of a solution that requires training or deep analysis of some observed behavior and instead, we can go straight into designing and thinking of it as more of like painting a picture. So you can make different choices, selections of behavior, you treat knobs and dials and have a very quick turnaround to see as you make these changes are you arriving on something that's interesting and appropriate for your agent behavior, for instance. >> It ends up being very flexible, we can work on multiple variables without imposing any rigid structure on the decision-making like we might with other decision-making frameworks. Now, we will find out there are some limits to what you can do with Fuzzy Logic, and that's largely to do with the fact that you can have a combinatorial explosion of all of the different possibilities that can arise in the rules that you define, the fuzzy rules. You can get to the point where it ends up not being very efficient. So Fuzzy Logic tends to work with smaller, more self-contained problems that don't have a large amount of variables or large number of things to consider. Now, in terms of the history of Fuzzy Logic, we won't get into a lot of the details that was first introduced by Lofti Zadeh from UC Berkeley. He introduced the original concept of Fuzzy Logic, and I believe it met resistance in academia pretty much right from the beginning. But it did quickly gain traction in electronic control systems, so anything from high-speed trains to rice cookers, other home appliances like a toaster, that sort of thing, and Japanese engineers were the first to really apply to commercial applications and it was quite popular approach, especially in 70s, 80s, and then we started to get in the 80s, specialized hardware controllers. So you'd have tools to populate these tables of rules, and they could run rather efficiently. And a good bit of research continuing from the 80s into the 90s. So there's certainly a well established engineering tradition of leveraging this Fuzzy Logic concept, and again, you also find the use of Fuzzy Logic in video games. Let's look at an example with golfing scenario where we have similar vague description of strategies for different golf shots that say an agent might take in a golf game. So if the ball is far from the hole and the green is slipping gently downward from left to right, then hit the ball firmly and add an angle slightly to the left of the flag. You can see here we have a number of different descriptions, again, we've got the subjective interpretations of different states that we might find certain variables in our game. Like the distance the ball is from the hole, the slope of the surface the ball is on, and also there's this vagueness or subjectivity too at the output, so how hard the ball is hit with a club, for instance, or the aim left or right relative to the direction of the flag or with the hole. So we might define some ranges for the subjective description, say for distance we have close and medium. The ball is between zero meters and two meters from the hole, we'll say is the range for close, and then medium could be 2-5 meters far as anything greater than five meters. But then what do you do when we get up near these transition points? So if the ball is at 4.99 meters away, we're going to have this abrupt transition perhaps if we go a little bit over 4.99, transition to five point something, then suddenly you've got whatever the strategy is associated with the far distance which is probably like hitting the ball harder. So if we maintain that abrupt transition, we might expect maybe the shot to be too short for medium and then we crossover that boundary for far. Now the shot's too far, we've got this abrupt transition with maybe a more conventional logic strategy. We might come up with, say, an approach that where we write code to represent one of these rules with the natural language description, with these subjective terms. Could perhaps come up with an equivalent where we've write the code to process the wind speed because we really want an absolute value for wind to make these comparisons. And then we've got maybe a range defined for the minimum that the strong wind can be, and the maximum, an also similar ranges for the distance. And then we will perform a inverse interpolation from the input variables, and then linear interpolation to define our output of our hit force and our angle. Now, as a programmer, you might be able to look at this code and pretty quickly figure out what it is, especially if you commonly use the linear interpolation code. But it's still very, I would argue much easier to read the natural language description of this particular strategy for driving the ball from the T, so that would have be even that much more true for someone that is not experienced programmer. Let's look at Boolean Logic and how we might define logical elements in classic symbolic AI, you're often working with predicates that return either true or false. So we can think in terms of the set membership, and these might be parametrized, say we have a combat video game, is armed with a parameter. Could be a particular agent. So you could pass an agent to this function and return true or false and this tells you a membership in a set. There's the armed agent set and then there's the injured set, so is injured and we pass in an agent and know whether it's injured or not, it's going to be true or false. So this is conventional logic and it has that very sharp true or false characteristic to it. So very much not the fuzziness that we've been suggesting so far for Fuzzy Logic. Now, with Fuzzy Sets, we have instead of it just being all or nothing true or false, we have this degree of membership. We will still have this ability to represent predicate type logic, but instead, for each set there'll be a degree of membership. And so this is a normalized value from 0-1, a floating point, so 0-1 inclusive, perhaps our agent has a 0.7% membership and is injured set. Now, that doesn't mean a 70% chance of being injured. It just means a 0.7 normalized scale value membership or degree of membership. So this is setting us up for this ability to consider not just a single predicate, but we might have multiple ones, maybe even predicates that would otherwise be in disagreement. For instance, you had these weird situations where you have a degree of membership for an agent is healthy set simultaneous with is injured. In Conventional Logic, you would expect these to be mutually exclusive. So you could only consider one or the other in terms of making any Boolean decision, but in Fuzzy Logic, this is perfectly acceptable that you have the non zero degree of membership for both of these predicates. >> So when you do have multiple degrees of membership that are non-zero, and they're both applied to the same crisp value whatever the observation of our world or game world. If these sets are applied to say temperature. So if you had, say, cold and hot and they're both non-zero, well, you would expect that whatever all of the different set memberships that there are where these non-zero degrees of membership, you'd expect maybe the sum should be 1, and that is inappropriate assumption to make. However, in practice, that isn't something that absolutely has to be imposed. Because you can take just a weighted average of all of the non-zero DOMs or degrees of membership for a particular variable and its set memberships. So once we have this notion of degree of membership in the, we'll call it fuzzy set. They can be one particular variable like temperature. It can be maybe multiple sets like cold and warm and hot. We have enough when we start to think about, how exactly does this algorithm work for fuzzy logic? There's three main steps here. We've got falsification, fuzzy rules, and defuzzification. So in the falsification step, this is where we take our crisp values. These come from your game world state maybe like a distance or temperature, that sort of thing. We're going to take those crisp values and we're going to apply them to a membership function and this membership function will then allow us to determine the degree of membership for different fuzzy states for that given value or variable. Then we apply all of the different activated fuzzy states, all of the activated states. We're going to apply those. So they're going to be in the antecedent. So each one is going to have a DOM or perhaps multiple ones because we might have some binary logic there, like cold and like the clothing you're wearing or your agent is wearing. Maybe deciding in terms of say, the thermostat example. You're going to use the degree of membership, which are the values that are somewhere between 0 and 1. So we will have some logic and the antecedent and then the consequent. That is the output. That's what's the decision made in terms of a decision-making response by, say the agent. That is then passed to the defuzzification step. So the consequence are fired into a crisp value. And so this whole process, you're going to have multiple fuzzy rules that get activated because of the multiple activations or multiple fuzzy set memberships that are driven by these crisp values and the overlapping membership functions. So you go in reverse at the end. You have defuzzification and that's where you get the opposite way. So it's like you are figuring out where membership functions intersect with the degree of membership going out. And so that gives you a crisp value going out the other way. The defuzzification, as we'll see, is being a lot more tricky than defuzzification. So for each of the different rules, for each antecedent, we're going to calculate the degree of membership for the input data. So again, those are going to be crisp values coming in, meaning the real world or the game world values, and then they're going to be converted into this fuzzy state. Then at that point, we can process the rules and then get to the point where we need to go back out again. We're going to be calculating the rules, whatever the conclusion is probably going to be involving multiple rules and it's going to be based on the values in the previous step. So those all be combined into a single conclusion that will come from the fuzzy set. At that point, we have to do this defuzzification. Again, we'll look at in more details here in a second. For any particular fuzzy rule, we're going to have taken various variables with crisp values. We're going to get degree of membership and this will probably involve some Boolean-like logic, like an AND or an OR. And we're going to have to perform a special operation on the antecedent to combine the effects of all of those antecedent terms. That's going to give us a mapping to the output fuzzy set which will be defuzzified. For instance, with an AND type of Boolean operation. Recall that these are going to be degrees of membership, so it's going to be like 0 to 1. What would be the equivalent of a Boolean operation? But now we have these normalized values. In the case of an AND where its often used, is the minimum. So the minimum of the two values. You might be wondering why we would use minimum and we'll see here in a second. But once you do that, that gives us now a membership value that transitions to the output. If condition then the consequent. Like in this example, if I'm close to the corner and I am traveling fast, like driving a race car perhaps, then I should break. So we can take the degree of membership for close to corner and the degree of membership for traveling quickly. So there'll be two different values. We'll take the minimum of the two. So that tells me the degree of membership in the should break strategy. That is a pretty straightforward operation to get to the point that we have the degree of membership and the consequent that we will then use for the defuzzification. >> Fuzzification, quickly I did the explaining before this involves a members function. Now these functions is really just a part of fuzzy logic design. There's not a truth or one way of doing things. Instead its just whatever is appropriate. And that often can vary just based on choice. Especially things like where did the ranges begin and end, and so on. If you look at the figure shown here in the slide, we've got a crisp value for health. And this is just the percentage of health that your agent has in a game. And we've got two degree of membership functions defined. So you can see that there's a range, in the case of hurt somewhere, I guess around from 0 to 10% of health. So very low health. That is one, meaning fully a member of the hurt set. If you see a crisp health value from 0-1, but then you see it tapers off from about 10% maybe to 40% of health. We see a drop-off of degree of membership. Simultaneously, we've got a crossfade going with healthy. Healthy starts at 10, with zero degree of membership, but it quickly ramps up to a full 1.0 value that is around 40 and it stays there all the way to a 100%. Now, we can have other shapes that we might use. Again, we might think that we want at any given point, how many ever fuzzy states or fuzzy membership functions overlap on this graph. The vertical line should always sum to one. And that is something that is potentially desirable with fuzzy logic, but it's not something that is absolutely set in stand. Again, because we can always do a waiting to compensate for times when it doesn't add up to one. So these functions, it is completely something that's part of the design process. We just select things that are appropriate. If we are attempting to sum to one certain shapes and combinations will make that easier to work with. For instance, across fade, you'd want your start and end of your cross, of your fade up or fade in and fade out, like you would want those to match. So if you have an API or tools for building fuzzy logic, you would probably have supports built-in to make that easy and efficient to lay out and make adjustments and have automatically adjusting one of them membership functions would adjust the other to preserve that sum to one possibility. These functions that can have different shapes and we'd have a trapezoidal. Perform the cross-fade or triangular shoulders, which are basically when your trapezoids run to the end or to the limits of the range for the crisp values. Here's some other visualizations of what we just talked about. You can see the different shapes that might be possibilities. We might also have fuzzification of small sets and enumerated types. And so in these cases, we can just treat these as lookup tables. For a particular enumerated type, we just look up and we will fraught from that lookup, we will get a single degree of membership value. So here's an example showing, say, maybe we have opponents that in a Kung-fu game. And these opponents observed in the game, there each wearing a different belt or sash and they have different colors. Those colors tell an agent how much fear to have. Maybe in that fear would perhaps drive evasive or defensive behavior more than aggression. This is how we could perhaps include this enumeration in fuzzy logic related to that. We briefly looked at how to deal with the equivalent of Boolean logic in our fuzzy logic. With the and example where we saw with the use of the minimum of two values. So if you have A and B, I didn't need to have the minimum. So similarly, you have a fuzzy logic operation for or. In this case, we'll take the max. And then not of a particular variable would be one minus the value and that would be one minus the degree of membership. You can also do what's called hedging. You can say that something is very or fairly. And so we can apply an exponent to the degree of membership value and that can bend the curve one way or another. That's something that doesn't even apply in Boolean logic. But it's something that's potential with fuzzy logic. Again, you might be wondering, well, why is it min and why is it max? This next slide here, I think, will help a lot with this. When you're considering the possibility that you have, say A and B, you might have two membership functions and those membership functions will overlap, and they can overlap. At the point where they overlap, that's the only place where the end can occur, so it's an intersection. It turns out that this inner section area can be defined by the minimum value, as you can see here, how it's depicted. Because the minimum value is whether it comes from the A side or the B side, it's always going to be less than or equal to applying the min operation that less than or equal to. So it's going to capture the part where the overlap is. One line of that part of the membership function is probably going to be. One or the other is going to be underneath the other. So A is under B or B is under A. Minimum defines that region. Now in the case of or it doesn't matter if both are present, like intersection of the curve, we just need the overall silhouette of the intersection. So even if, say A is at 0, if b is non-zero at that particular value, then you just go with whatever point it is in terms of degree of membership. I think this can give you a good intuition on why you're using min and max for AND, and OR. Now all of that said, this is arbitrary. The implementation of these, I guess Boolean equivalent for combining your fuzzy set. You could, for instance, have other roles. And so in fact, here are some that are effective and sometimes used in other approaches. You can use multiplication for and, and that works well. But then how do you define or, and so it has to rely on a little trick to figure out what the equivalent should be if we're using multiplication for the end. If you play around with, I guess the Boolean definition for and we can change things around and define in terms of a NOT. For a NOT, we're going to still use the one minus value, which makes sense to invert it to the opposite degree of membership. That in conjunction with or, you can see here the derivation of x or y for fuzzy logic, instead of the end result is you get the x plus y minus x times y. And so again, that is an alternate strategy, I guess potentially you could come up with other approaches as well. It really is what is effective for building the physiologic. So there's somewhat of an arbitrary aspect to the design of fuzzy logic, but you're really looking for consistency in terms of the interpretation. >> All right, so the defuzzication, I said before, this is a little bit trickier, like dealing with these Boolean operations like and, and or, I would say tends to get even more flexible and arbitrary in terms of what does it mean to perform defuzzication. Now in the case of the input variables this is very straightforward because we'd have a value on the x scale and so we could just draw a line vertically to figure out where it intersects with the degree of membership function. And then that y-value, that is the degree of membership value for that particular set. We are going the opposite way with defuzzication. So we're going to have a degree of membership which is along the y-axis. So now we're not guaranteed to only have that one intersection point, so we're going to be drawing a line across on the y-axis horizontally so find a point on y the degree of membership that we determined from the antecedent. We need to figure out where that goes for defuzzifying to get a crisp output value. So here is a demonstration of challenge that we're working with here. We've got these different degree of membership lines. We've maybe determined a degree of membership. It needs to be converted to a crisp value, which is on the x-axis. But we have this issue, so if you draw a line, we're going to get intersections possibly at more than one point. We might have only have one point. But we also have to consider the fact that if there is, imagine you take a full slice through, you're going to have points on parts of your degree of membership curve for the output variable that are above that value. So we also have to consider any place where the curve is above the degree of membership value in question. We'll have a whole range of valid movement speeds for that degree of membership. That's where the complication comes in. You end up with this whole range of values. What you generally end up doing is you take a slice through your degree of membership function. So if you have a trapezoid and you slice through some part of that trapezoid, you'll still end up with a trapezoid. It'll just be truncated a bit. It's going to be shorter. Well, how do you select a single crisp value from a whole range of valid values? This is again, something is arbitrary. You can pick different strategies and just see how well they work and maybe pick the one that's easiest to compute. That still gives good results empirically. So you might take say, the minimum of the maximum. Let's see if I can get my mouse cursor show up here for you. I think you can see it now. So we've got say here is where a degree of membership had lopped off the top of a degree of membership function for an output value. We could take the minimum of the maximum, the maximum being the highest degree of membership after we've pruned away whatever it was above. The minimum is in the context of the x value. So the minimum crisp value of the maximum observed. Or you can take the average, which would be, you find the average of the maximum. So you find all the places, the continuous area where the maximum occurred and then you take the average of that bisector or maximum of the maximum. Now in this case, I've skipped over a little bit here. We've got only one single degree of membership function that has been trimmed. But what you really end up with are multiple degree of membership functions that are all merged together, so all of the different fuzzy sets that are activated from your set of fuzzy rules. Any of them that have non-zero degree of membership, you actually merge all of those different degree of membership functions together wherever they've been cut off. So you do that intersection with the degree of membership. Whatever degree of membership it is, tells you the maximum allowed in the y-direction and that degree of membership direction, and then you merge them all. So you end up with these really weird shapes. So that's going to be, say for your different outputs strategy. So we might have maybe an agent that chooses between creeping, like for sneaking around or walking or running. You might have, say a degree of membership of a third for creep, a third for a walk, and a third for run. We could use this as weights and then apply this to a characteristic speed that being the crisp value that we're aiming for is the agents locomotion speed. So this characteristic speed would maybe be the average speed or just something that's hard-coded or configured, I guess, as part of the the overall fuzzy logic system. So you'd have the weight of a third multiplied or whatever that desired creeping speed is and then the third times the walk speed and third times the run speed and so that would give you a value. >> You may need to normalize the values if you haven't already guaranteed that the degrees of membership for the overlapping set or the membership functions for the input variables if those don't sum to one. And yes, there's different strategies we already looked at, but one that is probably the most robust but most computationally expensive is use a center of gravity. So again, you're going to trim each of your membership functions for your output in a trim those by determining, well, what was the degree of membership that came from the inputs after you applied the Boolean logic? So what's going to be the resulting output degree of membership? And then for each of those we're going to trim them. So in this slide here, you can see the trimming or cropping has been applied. So we've got this degree of membership function. and whatever the degree of membership determined there, we cut it off here, and then we join it with this degree of membership functions also been cropped. And then this one's been cropped. So if we can integrate under the sum of these cropped membership functions, we're going to see where the most area is, and then that will be the diversified value. Next step, I've got an example of selecting a rocket launcher for attack in a game where Agent choses maybe between different weapons. So this is from Buckland's programming game AI by example book and so it actually goes into a lot of detail on fuzzy logic solution that he uses in some of these examples. So let's say that we've got the following rules. So there's a bunch of rules that are related to when to use the rocket launcher. And so this is something where the rocket launcher has got not a lot of ammo, so it's a precious commodity. And so we want our agent to make good decisions about using the rocket launcher and not waste ammo. So you can see there's rules like if the target is far and ammo loads, then desirable and desirable in this case means it's desirable to use a rocket launcher for attack. If the target is far and ammo is okay then undesirable. So that means that if you only have a little bit of rocket ammo currently in a target far well, it's not desirable to shoot long distant shots with this precious ammo. But then you can see other scenarios like if the target is closed and ammo loads then undesirable. Now that is because the rocket launcher has an explosion. And we don't want the agent hurting themselves. So really there's this sweet spot of medium range. So if the target distance is medium and ammo loads are very desirable, but it's also very desirable if the ammo is okay and ammo is low is just desirable. So we've got all these different possibilities. We've got for our input crisp value that's going to be distance to target. And then also ammo status. So that's the count of rockets that we have in inventory. And so we have different membership functions for Target_Far, Target_Medium, and Target_Close. We have membership functions for the loads ammo, okay ammo, and low ammo. And so those rules will overlap. And as we evaluate all of these roles, that means that because of these overlapping membership functions, we're going to have non-zero values for multiple rules. So the way that we perform the fuzzy application is we just go iterate through each rule and then based on the membership on the input that we're considering, we will look at that crisp value on the graph and draw a line vertically from the crisp value, find where it intersects with the membership function if at all, and then that point of intersection, the y height of that intersection tells us the degree of membership for that particular fuzzy state. So then we will be doing that for both the distance to target and the anti-static. And then we'll have the AND operation, so we'll probably be performing the mean of the two. So whatever the degree of membership is for Target_Far and ammo loads, for instance, we take the minimum of the two. That's going to tell us the degree of membership for the consequent side said desirable. And then what are going to do is we're going to have to find all of the non-zero degree of membership on the consequent or the output side or the decision side in this case. And then we'll have to pick an appropriate strategy. So that's depicted here. I've got not the complete example. If you happen to have a Buckland's book, you can go through it completely. But so right below the rules, I believe this is for the second rule. So this is Target_Far and Ammo_Okay. And by the way, this scenario we've got a distance of 200 and ammo status of eight. So we have to go through all of these rules checking for distance 200 ammo rates. That means taking these two crisp values and performing the falsification. So here we can see for Rule 2, so Target_Far, so I needed the degree of membership function for Far, check at 200 and I find that that is 0.33. And then for ammo status, we've got eight. So that's right here. And then draw a vertical line with this is for ammo okay. So that particular ammo okay, membership function, we get the 0.78. That is our two values that we're comparing. Again, we're performing an AND operation, so for Rule 2 with AND it's 0.33 and 0.78 or the minimum, which of course will be 0.33. So now we know the degree of membership for undesirable. We can treat all of these rules as a table. So you can see the activated rules. Fuzzy set of activated rules right here. So we've got these different values. This is going to tell us all of the membership functions for the output are going to be desirable or undesirable and very desirable. And so at that point, we need to do the defalsification. So in terms of doing the defalsification, again, recall that we know a degree of membership, but we know also the output degree of membership function. So we crop the function by drawing a line from the value that's appropriate for each of these functions. So we're going to match these values with the right function. So we're going to crop them, then we're going to combine them all. And so that's shown here. And then we have to pick a strategy, we've got this weird shape. What are we going to use to calculate? So we could do like the center of mass approach where we integrate under the maximum value here or use one of the other strategies. >> In Buckland's example, we have the mean of the maximum, I believe. So we averaged at the maximum. So for each of the three functions rather than taking the center of mass, instead we identify where is the maximum and that's going to be the line farm from the truncation or the cropping. Each of these lines that you see for the three activated functions, we'll take the mean of those. That'll be in the middle of the flat plateaus of the line. That'll give us three values. And then we can use that to determine the overall crisp value output for desirability. It goes through the full example of performing the falsification, the evaluation rules and then the fuzzy rules and then the diversification. So there's a lot of flexibility here because there's different, well, we can pick different ways of performing the fuzzy logic like and's and or's. We also can pick the shape of our degree of membership functions on both the input and the output side and then we also are selecting what's the strategy we're using for diversification because we're going to have multiple rules activated and therefore multiple degree of membership functions that have to be used in the diversification. So we can use fuzzy logic in decision-making. In fact, we've already seen some examples of this. Use the fuzzy logic to select actions or behaviors or states and each action can be applied to varying degrees rather than selected discreetly. And so through application of the fuzzy logic this is going to allow us to blend actions, especially in transitional or gray areas where one action or another, it's not clear like one is appropriate more than another. So we can apply fuzzy logic to maybe a decision framework that's similar to rule-based systems and we've seen that already. But there's not really a formal name for this, but it's occasionally referred to as fuzzy state machines. However, in Millington's book, he actually describes something that's more specifically finite state machines with fuzzy state membership and transitions, or one or the other or both. So we're not going to call those fuzzy state machines. By the way, if you are interested in the fuzzy state machines, I'm not going to cover it in this lecture, but if you are interested, you can check it out in Millington's book. But back to using fuzzy logic for decision-making and more of a rule contexts. You'll also often hear of it as just fuzzy logic and that automatically implies fuzzy rules in use. So I'm just going to simply refer to it as a fuzzy rules. So the key aspects of this approach decisions are going to be made on some number of crisp inputs and each input is mapped to fuzzy states and so we've already gone through several examples with the fuzzy states so these are going to involve the degree of membership functions. We're going to take the crisp values and we're going to be able to map them to degree of membership for these fuzzy states. Some of those fuzzy states will end up with degree of membership that is non-zero. Again, we may require that the sum of all those non-zero degree of memberships, it's going to need to add up to one. In fact, that actually allows for an optimization which we'll discuss in a second. So our output states are going to be fuzzy states representing agent actions. Again, like we've seen, we can have multiple non-zero degree of membership for the output fuzzy states. We'll have this structure of if input state 1 and input state 2 and input state 3 and so on and so on through how many of our input states we have for a given set of rules, then we're going to have this output state. We might have an example if chasing and corner entry and going fast then break. So this double might be a role of describing a race car and if leading and mid corner and going slow, then accelerate. So each clause in a rule is a state from a different crisp input. And the clauses are combined with the fuzzy end, which is the mean operation. We're going to take the minimum of all of the degrees and memberships that are determined after being processed by the degree of membership function. In this structure, this fuzzy rule structure is going to be common to require all the fuzzy input state combinations to be represented in the overall set of rules. Many systems actually need that, need entries for all of those combinations. Then each fuzzy output state will be the maximum observed from the activated rules. So here is an example. We might have input degrees of membership. So we've got a corner entry, corner exit. So this would be like some analysis of the race track relative to the race car and then the speed of the car going fast, going slow. We've got this crisp values. They were mapped to degree of membership for these four input states. And then we've got rules that we can evaluate. Here's an example of the rules with the values embedded for example. So if corner entry that's currently at 0.1 degree of membership, and then, and going fast, that's 0.4. Then breaks. That means that the output degree of membership for the break, the break fuzzy state, that will be 0.1 because we take the minimum of 0.1 and 0.4. So similarly for the other examples, we get these various values. We got all of these roles with non-zero or the consequent or all of these is non-zero. So one thing that you can do with this framework for rule analysis, if you guarantee that the degrees of membership always sum to one so whatever the overlaps are, you have a cross fades, say this trapezoidal shapes always have a crossfade such that if you've got like 0.9 degree of membership on one, then you've got 0.1 on the other so it sums to one. If you do that, this opens up a possibility that as you sequentially evaluate rules, you can consider what you've seen before and knowing that there's the sum to one, you can recognize that it's impossible for a rule, as your partway through evaluating, to ever return a value bigger than wherever the previous highest scoring rule returned. So therefore, there's no point in continuing. So you can actually use this as an optimization so you don't have to fully evaluate every rule in the best case or maybe average case. In a worst-case, you would still have to evaluate all. But the end result is you can abandon fully evaluating some rules some of the time. >> Now in terms of performance, so if you've got O for the algorithms use of memories n plus m, where n is the number of input states and m is the number of output states. But you also need all those rules stored and if you recall mini implementations require that all possible combinations of the input state of fuzzy states be combined in these Boolean like sentences of the n's. So in that case, you end up with the O of the product of all the number of states n and then they're multiplied i times, so it's basically n^i and our i is the number of input variables. This can vary, but let's say that you have the same number of states for all variables just to simplify things. So you'd have n^i, but many cases it's going to vary, so you might have i input variables, so some will have one value or another number of states per variable, but we can maybe simplify this thing n^i. And then for time you're going to have i times n^i roughly. So the takeaway here is that performance, it has a huge weakness and that it is not going to scale, as you come up with more states per variable or more input variables overall, the things are just going to blow up and it's going to be very challenging to maintain. So one very popular approach with fuzzy logic is to try to avoid this combinatorial explosion, there's a strategy called Comb's method and this relies on a little simple bit of logic to simplify the problem overall. So if we consider the situation p and q implies r, that's basically what we have when we've got, say, two fuzzy states input on the antecedent. So if you have p and q implies, say, some action, we can restructure that to p implies r or q implies r and if you do that, this opens up an opportunity to substantially simplify things. So we'll now end up with complexity of time where we have our number of states times the input variables that we have. So much simpler, but we'll lose out because we can no longer combined our input states in a way that allows us to carve up different strategies. So in fact, there's no way that we can say, take a set of rules and then rip them apart into this new form, where we just have the single antecedent value that implies the output action because you'll end up with these confusing situations where you might say, for the same input variable, you've got two different opposing strategies. So it's best to actually start from the beginning to use the Comb's method as the beginning of designing your fuzzy logic solution. So you're not going to use the and's and or's in defining all of your rules. Instead, you will just come up with these different single fuzzy states that imply to perform some action or whatever the consequent is. And that again, we've vastly reduced the variables and once you're familiar with this new approach, you can still get combinations of behaviors, it's just the combinations aren't happening on the antecedent side of the rule. Instead, you're going to get the mixing and blending of possibilities is actually going to occur in the defuzzification stage. So you've got these different output states that are activated with varying degrees of membership and because of this varying degrees of membership and whatever the strategy is that it was selected for diversification, like the center of mass or the mean of maximum or all those different approaches that we saw before, based on that selection you get this interaction that still allows the Comb's method to be pretty capable and do many of the same things that the physiologic can do when you have the n's and o's more complicated Boolean operations. So that would definitely be something that you'd want to consider, if you have lots of states on your inputs and lots of input variables to go with it. So we'll wrap up fuzzy logic, so in terms of pros, easy to understand, very readable, this declarative form, especially when we have these set of fuzzy rules, it's efficient way to represent linguistic and subjective attributes of real world or in the video game world and in computing, you get the smooth transitions between behaviors because the fact that multiple of these fuzzy rules are simultaneously activated with these varying degrees of membership. And then whatever the strategy as we use for diversification, that's naturally going to blend because the output crisp value is going to get pulled one way or another as things gradually change, you're going to see that crisp value slide up and down the scale according to what rules activated. And it might move quicker or slower as new roles activate or no longer are activated. It's generally going to be easier to create fuzzy logic driven behavior than it is going to be if you're using, say, methods that involve training. So again, those methods that are more grounded in computer science and probability, probably are going to be able to come up with a more optimal solution than you can with fuzzy logic but that's almost addressing the wrong concern when we're talking about video games. The video game we're looking for compelling, interesting behavior, not necessarily optimization. Downsides defining set membership functions can be difficult, so there's lots of knobs and dials that we can be adjusting with physiologic and then of course, that will have an impact on what we observe. And debugging knowledge can be difficult, you might have, say, fuzzy rules that don't often get activated or when they are activated, their contribution is very small maybe have certain rules that tend to dominate a lot and conditions that would lead to other fuzzy rules being more activated or less, maybe they can just be very rare and therefore the testing is difficult. And the defuzzification step can have surprising subtleties and there's performance implications. So of course, if you change from one to the next, you might have drastically different behavior and so it might be a little bit of just random guesswork for some aspects of tuning fuzzy logic, that perhaps with experience, you gain some intuition and understanding of how best to configure and design your fuzzy logic rules.
