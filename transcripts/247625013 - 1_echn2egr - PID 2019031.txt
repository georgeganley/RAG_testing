>> Hello. In this lecture, we're going to look at how to calculate the distance between a point and a line segment. This is something that will be useful, especially with path networks determining if there is anything too close to an edge between nodes. We want to make sure that there's enough room for our agent to safely traverse from one node to the next. And so we need some way to check to see if anything is within the radius distance of the agent to one of these edges. So if anything intrudes on that corridor, then that is not a good edge to use because the agent would not be able to follow it. This calculation, in terms of robustness, we will need to use a floating point representation, this is because we're calculating an estimate of distance and just the nature of the discretization to integers or for computational geometry purposes, like pixels and so the distances won't necessarily be aligned with the x or the y-axis. And because they can be at arbitrary angles, that means we can have fractions of pixels and the estimates are probably being subpixel resolution, probably much more useful. So we'll work with floats and we can manage things and keep the appropriate robustness that we need for our calculations. At least in this situation. If you've already mapped values to integers, you could use floats as provided that your values aren't all ready too big, like your exponent too big might get to the point where you might hit a resolution of the floats like delta difference between each increment might become large and negatively impact calculations. That would probably only be a concern with procedural content generation, if you weren't renormalizing your coordinate system as the players moving around. You may have seen games such as Minecraft, I've seen a few videos where someone will walk in one direction for hours and hours or even days trying to find the end of Minecraft and I started to see weird anomalies. That is, I'm assuming, is related to the floats getting so big that the calculations are beginning to be impacted by the fact that large exponent that you're no longer able to differentiate between tiny values and so causing issues. So I would be concerned in those sorts of scenarios, but you could always renormalize, reset the origin as you're moving. But really not anything to worry about in reasonable circumstances in terms of this implementation. This algorithm it's got multiple steps. It's not especially complicated, but what we want to do is find the closest point on a line segment to a candidate points or test point P. We want to see how far our test point P is from our line segment. It's easier to define the problem if you're thinking in terms of an infinite line, because then we're just thinking about projection, so we can project. In this case, we've got the two endpoints of our line segment AB and then we've got P. So we want to project the vector AP onto AB. Once we perform that projection, that's like we're dropping the point straight down. Like if you took your line segment and just made that your x-axis, and then rotated everything with it, where P is relative, your just be dropping P straight down onto the line, that's the effect of performing the projection. Now if it's an infinite line, it could drop well beyond the endpoints of our line segments, so that wouldn't be the correct point to be measuring our distance from. The next phase is we want to see, well, if we did the projection and found the closest to the infinite line, is that point between the endpoints of our line segment. If that's the case, then we would measure the distance from the projection point. We'll call that CP for closest point. So we'll create the vector C P to P1, then take the magnitude of that would be or length. But if our projection that CP ends up being on the outside of A or B, then we would pick either A or B. So if you're on the outside of B, you would pick B. Then if you're outside of A, you would pick A because that is the closest point on the line segment to measure the distance from. There's a lot of ways that we could set that up, but it'd be nice to have something that is efficient in terms of computation. And so I'm going to go through how to set up a reasonably efficient approach to this. >> One thing that's always good in video games is to avoid square roots or anytime you're computing something over and over, really, that tends to be a very expensive operation. So let's start off working with formal definition of projection. So here we've got a scenario where we've got vector b and vector a. And so we're performing a projection of a onto b. So that projected vector is going to be a scalar a_1 times b normalized. So a unit vector form of b normalizing, a vector just means dividing it by its magnitude. And so that a_1 scalar not bold with my mouse over hopefully, video encoding picks it up. So the scalar, which we see in the first equation times the unit vector b, we can have an angle form so the magnitude of vector a times cosine of Theta, where Theta is the angle between vectors a and b, or a more preferably for our case to use the dot product. So that would be vector a dot product with unit vector b. If we expand how to calculate or substitute in for unit vector b, that would be vector a dot product with vector b over the magnitude of b. So if we take that and plug it into the first equation, the one on the top here. So we're going to plug this in here, so recall that all of this that we've got at the end is our scalar a_1. So we plug that in for the scalar, so now we have the projected vector a with a little subscript 1 there, is equal to in parentheses vector a dot product vector b over magnitude of b that's going to the unit vector, and then that times unit vector b which we can substitute in there for how we get that as well, which is also vector b over magnitude of vector b. So we can simplify all that and then what you get is projected vector a is equal to vector a dot vector b times vector b over the magnitude of b squared. Now this is nice because if you recall that the magnitude is the square root of sum of squares of the individual terms. So we're taking a square root and squaring it. So that cancels that out for us. And so that is getting rid of the square root so that's a nice thing to have. The other thing we can do, is that we can define a normalized scalar. So rather than using unit vector b to define where along the vector b we are or in the direction of vector b, we can say that the projected vector a is equal to t, which is equal to all this stuff that we separated out from the equation on the left, that's t times vector b. So we don't have the unit vector b. What you're going to end up getting from that is that t value, it'll be 0 at the beginning point of vector b, and if it's 0.5 like 50%, it'll be halfway down the length, and if it's 1 it'd be at the very end of b. So that is nice to have because now when we actually calculate our projection, to get that if I go back, slide when we were talking about finding that closest point, the closest point is going to be defined by t. We're going to have this t in this nice form. And we can just check to see if t is greater than 1 and then if it's greater than 1, we would know it's beyond B, and if it's less than 0, it would be behind A. So in this case as we know to just not use a distance from cp to P, we would instead use the distance from P to either A or B, so we just have some simple conditional logic were we can look at t. So this is a nice little concise way of handling the calculation. We got rid of the square root and then we've normalized our scalar to be in the context of the full length of B. So that makes implementation very easy. There's only one other thing we got to watch out for and that is if A and B, those two points that define line segment there, if they're the same point because that would result in divide by 0 because we have this magnitude term here, and we don't want that divide by 0. So we needs some conditional logic to test if A and B are the same, if they are the same, then we just have special case where the distance we return is going to be the distance from, we just pick A or B because it's the same and just take the relative position vector between our test point and A or B, and then the magnitude of that, and that is our distance to the line even though it's not really a line. But yes, that avoids the divided by 0, so this is pretty straightforward implementation, but it has some nice little optimization is to it.
