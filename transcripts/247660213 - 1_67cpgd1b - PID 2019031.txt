>> Hello. In this lecture, we're going to continue looking at procedural content generation. In particular, we're going to look at Constraint Satisfaction and Wave Function Collapse. So we've previously explored rule-based systems, such as the rules that we discussed for controlling Perlin noise. So we saw how we can get this nice emergent output. Often can get interesting results, but it's difficult to control the output. In many cases, you're best off just playing around with different rules. And if you see something interesting, taking advantage of it, as opposed to having a very well-thought-out design in mind that you're trying to very precisely create in terms of your procedural content. You can't always pull that off. There's also generative grammars. This can create high-quality output. The authors can have a bit more control, but it does depend on expertise in terms of authoring some experience in designing the components and the rules. And search based techniques can be pretty powerful because it cuts back on authoring burden. You don't need to design any rules or generative grammar. You just need to be able to define a heuristic or fitness function and then of course also have a searchable representation, perhaps involving discretization. But that can be unintuitive and difficult for many designers to work with. So we might consider a new approach, a bit of a hybrid of some of the techniques we've seen before. And that is constraint satisfaction. Also sometimes referred to as constraint solving or constraint propagation. It's similar to search. In fact, it has an element of searching to it, but instead of a heuristic, designers give constraints. So these constraints are facts that must be true in the final output. So whatever the end result of the constraint satisfaction or the propagation of constraints that must be held true. And so constraints can be authored or learned from an example. So with a constraint satisfaction problem, we have as input a set of variables, and a set of all values that can go into the slots, and a set of constraints that relate slots to each other. The output is all variables are filled with a specific value. So a trivial example would be a name generator. You have variables such as first name and last name. And then values would be lists of names. And the constraints would be the names cannot start with the same letter. That would just one example of constraint. You might have some others as well, maybe there's some other initials combinations that are not allowed or whatever else they you come up with. Maybe if you had a middle name also, you would want the gender, the most common gender to match with the first and middle name, perhaps, those things. So if you have a large list of names, well, there's lots of possibilities for any of the variables.So when you start off for each slot, you have potentially a huge list of valid values that can go in each slot. But if you pick one of the variables, likely you pick a first name, well, then that there is a constraint that's imposed on the last name. So as soon as that first name is picked. If you pick Jeff with this particular role, then you would have to exclude Johnson and in any other last name with a J. So you actually would keep track of that in terms of the logic you would cross off or remove from a valid set for that variable. So initially all variables have a list of all values that could potentially be used and then each update from one of the variables, you just arbitrarily pick what is going to be so this is the collapse. And based on the constraints, well, you expand out from the value that was collapsed you expand out the constraints? Which other variables are affected or impacted by that collapse? And that's going to be dictated by the rules or whatever the constraints are, so you're going to remove from the surrounding variables. Whatever the possibilities were that they did have, are now going to be reduced according to the constraints. So you continue this process iteratively over and over collapsing a variable. And so this, it's generative. As long as you're driving this by random number generation, you can just randomly pick a variable, collapse it by picking a specific value, propagate the constraints. And so that's going to control your content and it's going to force combinations of variables that meet the authors requirements. So if you've ever played Sudoku before, that is gamified constraint propagation. So you've got the different constraints about rows and columns and was it three by three groups? You've got rows, columns and groups all superimposed onto one board and you're given a few clues which you can think of as constraint collapse. And from that, it's your job to do the propagation of the constraints. They're designed in such a way that, that's challenging to do. But yourself might randomly pick a value to apply to say, some cell and then you will propagate and the idea is you either look for a valid board or more likely you're picking a value that you expect to have a very shallow sequence to an invalid board configuration. So you have a constraint or a set of constraints that tell you what valid solutions are. So if you can quickly find an invalid solution through the selection of a particular constraint then you know that was like a wrong choice and scratch it off. Now in terms of how you play it, a lot of people, when they play sudoku, they keep notes on say, a sheet of paper. Let's say playing in the newspaper and it'll be just like what's been described so far with the constraint and satisfaction. So you might keep track of all of the valid numbers that a cell could currently take on. So you might say, some particular cell might be it could be like a one or a five or a seven. And so you know that this is the only values it could be. And then that'll change as you figure out other numbers, you'll start to scratch off more and more numbers that each cell could be. It's a similar thing. Fundamentally, these are both for procedural content generation and for the puzzles you're propagating these constraints. >> Constraints satisfaction is basically a search, but it goes a lot quicker because you're constantly pruning the search space. So if you think of this branching factor of all the different possibilities that any variable could take on, the constraints trim that down considerably so that it's much easier to search through the space for a valid configuration. So you could use constraint satisfaction or something like generating a dungeon room. So here's an example of exactly what we're talking about with the variables and all the possible values that we're keeping track of all of the valid values in a current step of the search process and then as we collapse where we're going to propagate constraints. Let's say we have a grid and right now all of the different rooms in the dungeon are currently possible except for E, which I believe is for the exit. So we have these constraints, there must be a path from the entrance to all the treasure and enemies, so the E is the entrance, I guess it's the entrance and the exit is where the character can go into the dungeon and then start exploring and try to find treasure and enemies to fight. So there must be a path from the entrance to all treasure and all enemies. There can only be at most one treasure. There can only be at most two enemies. Enemies cannot be next to each other. So those are the constraints. Right now our dungeon, we have a large number of possibilities in terms of all of these different rooms. It can be 1, 2, 3 or 4 of us, so that would be an empty area, a wall, an enemy, or a treasure. We might pick a particular spot to say place an enemy. This is just a randomly selected dungeon grid cell and we're going to collapse down to an enemy value. So as soon as we do that, we can propagate our constraints and so the one that is relevant in this case is that enemies cannot be next to each other. You'll notice that up into the left and to the right we've removed that possibility of an enemy being placed. So now we only have 1, 2, 4, 1, 2, 4, 1, 2, 4. So next, we can collapse again and we might randomly land on the bottom-right cell, and we might randomly assign to be a treasure. And so once that is set, there can only be at most one treasurer. So this constraint propagates to every single cell in the map, and so we reduce that possibility 4. And we can continue on with this, maybe placing a wall and so we have, there must be a path from the entrance to all treasure and all enemies. So that will mean that we can't say wall off, the enemy, or the treasurer. So that's going to cause some different propagation. So you can get the idea of how this works. It's driven by random number generation, but it's done in this constrained way so that we get content that meets some gameplay or aesthetic purpose perhaps. So it can be very powerful for generating content. If you end up with output that doesn't look good, you can just add more constraints. You don't have to consider heuristics with this interaction that evaluation can have and it tends to be a lot easier to work with. But you do need to strike a balance between being overly constrained and avoiding bad outputs. If you're too constrained you're not going to be able to generate much in the way of variety. But in general, designers prefer being able to apply constraints. It's a more intuitive declarative specification as supposed to tuning a heuristic or a fitness function. Now if you don't want to write your constraints, you can instead have the algorithm learn them. So this is where a wave function collapse comes in and has become very popular strategy for procedural content generation in game design. You might give a little example in terms of a pattern that you're looking for and then you have an algorithm that evaluates that pattern. Basically generates constraint type rules from just looking at the example or set of examples. This has been used in different games. There are code examples out there such as the link provided and can give a lot of interesting results. The basic high-level concept of what's going on is you provide some sample input then the algorithm is going to derive legal patterns from that, and it does so by looking at intersections of patterns to get the constraints. So basically, for these 2D images is how can you overlap parts of the image with itself or tiling the image, but then overlaying them. What would be different valid possibilities when doing so? >> So the wave function collapse algorithm generating patterns from the sample, then it runs this build propagator step. And then while not finished, observe what has been created. So it's basically doing the classic collapse of the constraint satisfaction collapse. When a certain choice is made, then you propagate according to the rules that were generated from the provided patterns. So this is something that again has become very popular and it can even have some interactive user selection. So rather than just randomly picking, you can have a designer-driven approach to building. Here's a little video that demonstrates this. So what you're seeing is a little interface that applies to wave function collapse. But the collapse is the user selecting and then the user can decide what are the some mix of automating the pattern finding and specifying the constraints. Once the constraints are applied, you can then iterate on this overall and generate entirely new combinations of tiles to create these 2D environments. So it's an interesting area for procedural content generation, and it gives some pretty nice results as well. Here's a simple little example where we have our example pattern and then that can be used to generate an environment. So the collapse involves stamping out of the pattern randomly somewhere in the environment. Maybe just a little part of the pattern could be stamped. So for instance, it might partially overlap with an edge. Then once it's stamped, you can overlay the pattern with the content that currently exist and so there's going to be some overlays that don't, where the pattern doesn't fit. So those won't be options, but there will be places it does fit, and then that basically is like a rubber stamp or with ink and you can, as long as you can fit the underlying pattern with some subset of the example, then you can keep stamping it out. So with a two-by-two set of being applied to a two-by-two area, you can align it either directly superimposed or shifted left or right or up or down or up into the left, up into the right, and as long as, so you could randomly select between these different possibilities as you're filling in the content area. So this is showing how you could generate from that simple pattern, these different possibilities. So this might generate, say, a background texture or maybe cityscape like blocks in a city. Maybe bricks in the wall. So there's lots of things that you could do with the constraint satisfaction and so the smaller the pattern, you can get these more emergent possibilities. But if you want to maintain more structure, you can have a bigger example tile. That's going to considerably limit what are the valid overlap that you might use for that rubber-stamping process. So advantages of constraint satisfaction. The constraints are more intuitive than heuristics. It works well for declarative authoring, it's faster in many cases than search due to the nature of how it prunes away possibilities though it's slower to generate these due to the propagation. That could potentially be prohibitive if there is a lot of complexity in that propagation. And of course that would be likely the case with the wave function collapses by example like we've seen, we saw with the little two-by-two tile how we had all these different possibilities for overlaying. That is going to take a while to do that evaluation. But you can learn the constraints from examples and even have hybrid solutions where you have a mix of learning from example and then fine-tuning with the human intervention like we saw in one example. Downsides though, you must be able to represent the problem in terms of formal logic. You have to actually be able to figure out what are these very well-defined constraints. So this might be easier for some problems than others. If you have very specific gameplay rules that suggests maybe some straightforward rules like you might find with the dungeon generation. But if you don't have these well-defined rules, then things can get a lot trickier [NOISE].
